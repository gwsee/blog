// Code generated by ent, DO NOT EDIT.

package ent

import (
	"blog/internal/ent/account"
	"blog/internal/ent/accountexperience"
	"blog/internal/ent/accountproject"
	"blog/internal/ent/blogs"
	"blog/internal/ent/blogscomment"
	"blog/internal/ent/blogscontent"
	"blog/internal/ent/files"
	"blog/internal/ent/filesextend"
	"blog/internal/ent/predicate"
	"blog/internal/ent/travel"
	"blog/internal/ent/travelextend"
	"blog/internal/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount           = "Account"
	TypeAccountExperience = "AccountExperience"
	TypeAccountProject    = "AccountProject"
	TypeBlogs             = "Blogs"
	TypeBlogsComment      = "BlogsComment"
	TypeBlogsContent      = "BlogsContent"
	TypeFiles             = "Files"
	TypeFilesExtend       = "FilesExtend"
	TypeTravel            = "Travel"
	TypeTravelExtend      = "TravelExtend"
	TypeUser              = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account       *string
	password      *string
	email         *string
	description   *string
	nickname      *string
	avatar        *string
	blog_num      *int
	addblog_num   *int
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *AccountMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AccountMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *AccountMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AccountMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AccountMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AccountMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *AccountMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AccountMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AccountMutation) ResetAvatar() {
	m.avatar = nil
}

// SetBlogNum sets the "blog_num" field.
func (m *AccountMutation) SetBlogNum(i int) {
	m.blog_num = &i
	m.addblog_num = nil
}

// BlogNum returns the value of the "blog_num" field in the mutation.
func (m *AccountMutation) BlogNum() (r int, exists bool) {
	v := m.blog_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogNum returns the old "blog_num" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBlogNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogNum: %w", err)
	}
	return oldValue.BlogNum, nil
}

// AddBlogNum adds i to the "blog_num" field.
func (m *AccountMutation) AddBlogNum(i int) {
	if m.addblog_num != nil {
		*m.addblog_num += i
	} else {
		m.addblog_num = &i
	}
}

// AddedBlogNum returns the value that was added to the "blog_num" field in this mutation.
func (m *AccountMutation) AddedBlogNum() (r int, exists bool) {
	v := m.addblog_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogNum resets all changes to the "blog_num" field.
func (m *AccountMutation) ResetBlogNum() {
	m.blog_num = nil
	m.addblog_num = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, account.FieldAvatar)
	}
	if m.blog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldCreatedBy:
		return m.CreatedBy()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldUpdatedBy:
		return m.UpdatedBy()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldDeletedBy:
		return m.DeletedBy()
	case account.FieldAccount:
		return m.Account()
	case account.FieldPassword:
		return m.Password()
	case account.FieldEmail:
		return m.Email()
	case account.FieldDescription:
		return m.Description()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldAvatar:
		return m.Avatar()
	case account.FieldBlogNum:
		return m.BlogNum()
	case account.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldAvatar:
		return m.OldAvatar(ctx)
	case account.FieldBlogNum:
		return m.OldBlogNum(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.addblog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.AddedCreatedAt()
	case account.FieldCreatedBy:
		return m.AddedCreatedBy()
	case account.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case account.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case account.FieldDeletedAt:
		return m.AddedDeletedAt()
	case account.FieldDeletedBy:
		return m.AddedDeletedBy()
	case account.FieldBlogNum:
		return m.AddedBlogNum()
	case account.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldAvatar:
		m.ResetAvatar()
		return nil
	case account.FieldBlogNum:
		m.ResetBlogNum()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountExperienceMutation represents an operation that mutates the AccountExperience nodes in the graph.
type AccountExperienceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	company          *string
	role             *string
	location         *string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	description      *string
	responsibilities *string
	achievements     *string
	skills           *[]string
	appendskills     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AccountExperience, error)
	predicates       []predicate.AccountExperience
}

var _ ent.Mutation = (*AccountExperienceMutation)(nil)

// accountexperienceOption allows management of the mutation configuration using functional options.
type accountexperienceOption func(*AccountExperienceMutation)

// newAccountExperienceMutation creates new mutation for the AccountExperience entity.
func newAccountExperienceMutation(c config, op Op, opts ...accountexperienceOption) *AccountExperienceMutation {
	m := &AccountExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountExperienceID sets the ID field of the mutation.
func withAccountExperienceID(id int) accountexperienceOption {
	return func(m *AccountExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountExperience
		)
		m.oldValue = func(ctx context.Context) (*AccountExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountExperience sets the old AccountExperience of the mutation.
func withAccountExperience(node *AccountExperience) accountexperienceOption {
	return func(m *AccountExperienceMutation) {
		m.oldValue = func(context.Context) (*AccountExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountExperience entities.
func (m *AccountExperienceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountExperienceMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountExperienceMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *AccountExperienceMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AccountExperienceMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountExperienceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountExperienceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountExperienceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountExperienceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountExperienceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountExperienceMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountExperienceMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *AccountExperienceMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AccountExperienceMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountExperienceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountExperienceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountExperienceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountExperienceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountExperienceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountExperienceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountExperienceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AccountExperienceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AccountExperienceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountExperienceMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountExperienceMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountExperienceMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountExperienceMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountExperienceMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *AccountExperienceMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountExperienceMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AccountExperienceMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountExperienceMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountExperienceMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCompany sets the "company" field.
func (m *AccountExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AccountExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *AccountExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetRole sets the "role" field.
func (m *AccountExperienceMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *AccountExperienceMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AccountExperienceMutation) ResetRole() {
	m.role = nil
}

// SetLocation sets the "location" field.
func (m *AccountExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *AccountExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *AccountExperienceMutation) ResetLocation() {
	m.location = nil
}

// SetStart sets the "start" field.
func (m *AccountExperienceMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *AccountExperienceMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *AccountExperienceMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *AccountExperienceMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *AccountExperienceMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *AccountExperienceMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *AccountExperienceMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *AccountExperienceMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *AccountExperienceMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *AccountExperienceMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetDescription sets the "description" field.
func (m *AccountExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountExperienceMutation) ResetDescription() {
	m.description = nil
}

// SetResponsibilities sets the "responsibilities" field.
func (m *AccountExperienceMutation) SetResponsibilities(s string) {
	m.responsibilities = &s
}

// Responsibilities returns the value of the "responsibilities" field in the mutation.
func (m *AccountExperienceMutation) Responsibilities() (r string, exists bool) {
	v := m.responsibilities
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibilities returns the old "responsibilities" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldResponsibilities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibilities: %w", err)
	}
	return oldValue.Responsibilities, nil
}

// ResetResponsibilities resets all changes to the "responsibilities" field.
func (m *AccountExperienceMutation) ResetResponsibilities() {
	m.responsibilities = nil
}

// SetAchievements sets the "achievements" field.
func (m *AccountExperienceMutation) SetAchievements(s string) {
	m.achievements = &s
}

// Achievements returns the value of the "achievements" field in the mutation.
func (m *AccountExperienceMutation) Achievements() (r string, exists bool) {
	v := m.achievements
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievements returns the old "achievements" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldAchievements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievements: %w", err)
	}
	return oldValue.Achievements, nil
}

// ResetAchievements resets all changes to the "achievements" field.
func (m *AccountExperienceMutation) ResetAchievements() {
	m.achievements = nil
}

// SetSkills sets the "skills" field.
func (m *AccountExperienceMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *AccountExperienceMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the AccountExperience entity.
// If the AccountExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountExperienceMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *AccountExperienceMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *AccountExperienceMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *AccountExperienceMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// Where appends a list predicates to the AccountExperienceMutation builder.
func (m *AccountExperienceMutation) Where(ps ...predicate.AccountExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountExperience).
func (m *AccountExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountExperienceMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, accountexperience.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, accountexperience.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, accountexperience.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, accountexperience.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, accountexperience.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, accountexperience.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, accountexperience.FieldUserID)
	}
	if m.company != nil {
		fields = append(fields, accountexperience.FieldCompany)
	}
	if m.role != nil {
		fields = append(fields, accountexperience.FieldRole)
	}
	if m.location != nil {
		fields = append(fields, accountexperience.FieldLocation)
	}
	if m.start != nil {
		fields = append(fields, accountexperience.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, accountexperience.FieldEnd)
	}
	if m.description != nil {
		fields = append(fields, accountexperience.FieldDescription)
	}
	if m.responsibilities != nil {
		fields = append(fields, accountexperience.FieldResponsibilities)
	}
	if m.achievements != nil {
		fields = append(fields, accountexperience.FieldAchievements)
	}
	if m.skills != nil {
		fields = append(fields, accountexperience.FieldSkills)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountexperience.FieldCreatedAt:
		return m.CreatedAt()
	case accountexperience.FieldCreatedBy:
		return m.CreatedBy()
	case accountexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountexperience.FieldUpdatedBy:
		return m.UpdatedBy()
	case accountexperience.FieldDeletedAt:
		return m.DeletedAt()
	case accountexperience.FieldDeletedBy:
		return m.DeletedBy()
	case accountexperience.FieldUserID:
		return m.UserID()
	case accountexperience.FieldCompany:
		return m.Company()
	case accountexperience.FieldRole:
		return m.Role()
	case accountexperience.FieldLocation:
		return m.Location()
	case accountexperience.FieldStart:
		return m.Start()
	case accountexperience.FieldEnd:
		return m.End()
	case accountexperience.FieldDescription:
		return m.Description()
	case accountexperience.FieldResponsibilities:
		return m.Responsibilities()
	case accountexperience.FieldAchievements:
		return m.Achievements()
	case accountexperience.FieldSkills:
		return m.Skills()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountexperience.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case accountexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountexperience.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case accountexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountexperience.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case accountexperience.FieldUserID:
		return m.OldUserID(ctx)
	case accountexperience.FieldCompany:
		return m.OldCompany(ctx)
	case accountexperience.FieldRole:
		return m.OldRole(ctx)
	case accountexperience.FieldLocation:
		return m.OldLocation(ctx)
	case accountexperience.FieldStart:
		return m.OldStart(ctx)
	case accountexperience.FieldEnd:
		return m.OldEnd(ctx)
	case accountexperience.FieldDescription:
		return m.OldDescription(ctx)
	case accountexperience.FieldResponsibilities:
		return m.OldResponsibilities(ctx)
	case accountexperience.FieldAchievements:
		return m.OldAchievements(ctx)
	case accountexperience.FieldSkills:
		return m.OldSkills(ctx)
	}
	return nil, fmt.Errorf("unknown AccountExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case accountexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case accountexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case accountexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accountexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case accountexperience.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case accountexperience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case accountexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case accountexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case accountexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accountexperience.FieldResponsibilities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibilities(v)
		return nil
	case accountexperience.FieldAchievements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievements(v)
		return nil
	case accountexperience.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	}
	return fmt.Errorf("unknown AccountExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, accountexperience.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, accountexperience.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, accountexperience.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, accountexperience.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, accountexperience.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, accountexperience.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, accountexperience.FieldUserID)
	}
	if m.addstart != nil {
		fields = append(fields, accountexperience.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, accountexperience.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountexperience.FieldCreatedAt:
		return m.AddedCreatedAt()
	case accountexperience.FieldCreatedBy:
		return m.AddedCreatedBy()
	case accountexperience.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case accountexperience.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case accountexperience.FieldDeletedAt:
		return m.AddedDeletedAt()
	case accountexperience.FieldDeletedBy:
		return m.AddedDeletedBy()
	case accountexperience.FieldUserID:
		return m.AddedUserID()
	case accountexperience.FieldStart:
		return m.AddedStart()
	case accountexperience.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case accountexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case accountexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case accountexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case accountexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case accountexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case accountexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case accountexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case accountexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown AccountExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountExperienceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountExperienceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountExperienceMutation) ResetField(name string) error {
	switch name {
	case accountexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountexperience.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case accountexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountexperience.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case accountexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountexperience.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case accountexperience.FieldUserID:
		m.ResetUserID()
		return nil
	case accountexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case accountexperience.FieldRole:
		m.ResetRole()
		return nil
	case accountexperience.FieldLocation:
		m.ResetLocation()
		return nil
	case accountexperience.FieldStart:
		m.ResetStart()
		return nil
	case accountexperience.FieldEnd:
		m.ResetEnd()
		return nil
	case accountexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case accountexperience.FieldResponsibilities:
		m.ResetResponsibilities()
		return nil
	case accountexperience.FieldAchievements:
		m.ResetAchievements()
		return nil
	case accountexperience.FieldSkills:
		m.ResetSkills()
		return nil
	}
	return fmt.Errorf("unknown AccountExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountExperienceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountExperienceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountExperienceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccountExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountExperienceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccountExperience edge %s", name)
}

// AccountProjectMutation represents an operation that mutates the AccountProject nodes in the graph.
type AccountProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	experience_id    *int
	addexperience_id *int
	title            *string
	description      *string
	skills           *[]string
	appendskills     []string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	link             *string
	photos           *[]string
	appendphotos     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AccountProject, error)
	predicates       []predicate.AccountProject
}

var _ ent.Mutation = (*AccountProjectMutation)(nil)

// accountprojectOption allows management of the mutation configuration using functional options.
type accountprojectOption func(*AccountProjectMutation)

// newAccountProjectMutation creates new mutation for the AccountProject entity.
func newAccountProjectMutation(c config, op Op, opts ...accountprojectOption) *AccountProjectMutation {
	m := &AccountProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountProjectID sets the ID field of the mutation.
func withAccountProjectID(id int) accountprojectOption {
	return func(m *AccountProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountProject
		)
		m.oldValue = func(ctx context.Context) (*AccountProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountProject sets the old AccountProject of the mutation.
func withAccountProject(node *AccountProject) accountprojectOption {
	return func(m *AccountProjectMutation) {
		m.oldValue = func(context.Context) (*AccountProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountProject entities.
func (m *AccountProjectMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountProjectMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountProjectMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *AccountProjectMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AccountProjectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountProjectMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountProjectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountProjectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountProjectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountProjectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountProjectMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountProjectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *AccountProjectMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AccountProjectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountProjectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountProjectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountProjectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountProjectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountProjectMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountProjectMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AccountProjectMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AccountProjectMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountProjectMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountProjectMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountProjectMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountProjectMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountProjectMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *AccountProjectMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountProjectMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AccountProjectMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountProjectMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountProjectMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetExperienceID sets the "experience_id" field.
func (m *AccountProjectMutation) SetExperienceID(i int) {
	m.experience_id = &i
	m.addexperience_id = nil
}

// ExperienceID returns the value of the "experience_id" field in the mutation.
func (m *AccountProjectMutation) ExperienceID() (r int, exists bool) {
	v := m.experience_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceID returns the old "experience_id" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldExperienceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceID: %w", err)
	}
	return oldValue.ExperienceID, nil
}

// AddExperienceID adds i to the "experience_id" field.
func (m *AccountProjectMutation) AddExperienceID(i int) {
	if m.addexperience_id != nil {
		*m.addexperience_id += i
	} else {
		m.addexperience_id = &i
	}
}

// AddedExperienceID returns the value that was added to the "experience_id" field in this mutation.
func (m *AccountProjectMutation) AddedExperienceID() (r int, exists bool) {
	v := m.addexperience_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperienceID resets all changes to the "experience_id" field.
func (m *AccountProjectMutation) ResetExperienceID() {
	m.experience_id = nil
	m.addexperience_id = nil
}

// SetTitle sets the "title" field.
func (m *AccountProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AccountProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AccountProjectMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *AccountProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountProjectMutation) ResetDescription() {
	m.description = nil
}

// SetSkills sets the "skills" field.
func (m *AccountProjectMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *AccountProjectMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *AccountProjectMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *AccountProjectMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *AccountProjectMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetStart sets the "start" field.
func (m *AccountProjectMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *AccountProjectMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *AccountProjectMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *AccountProjectMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *AccountProjectMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *AccountProjectMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *AccountProjectMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *AccountProjectMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *AccountProjectMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *AccountProjectMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetLink sets the "link" field.
func (m *AccountProjectMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *AccountProjectMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *AccountProjectMutation) ResetLink() {
	m.link = nil
}

// SetPhotos sets the "photos" field.
func (m *AccountProjectMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *AccountProjectMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the AccountProject entity.
// If the AccountProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountProjectMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *AccountProjectMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *AccountProjectMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *AccountProjectMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// Where appends a list predicates to the AccountProjectMutation builder.
func (m *AccountProjectMutation) Where(ps ...predicate.AccountProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountProject).
func (m *AccountProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountProjectMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, accountproject.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, accountproject.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, accountproject.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, accountproject.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, accountproject.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, accountproject.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, accountproject.FieldUserID)
	}
	if m.experience_id != nil {
		fields = append(fields, accountproject.FieldExperienceID)
	}
	if m.title != nil {
		fields = append(fields, accountproject.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, accountproject.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, accountproject.FieldSkills)
	}
	if m.start != nil {
		fields = append(fields, accountproject.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, accountproject.FieldEnd)
	}
	if m.link != nil {
		fields = append(fields, accountproject.FieldLink)
	}
	if m.photos != nil {
		fields = append(fields, accountproject.FieldPhotos)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountproject.FieldCreatedAt:
		return m.CreatedAt()
	case accountproject.FieldCreatedBy:
		return m.CreatedBy()
	case accountproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountproject.FieldUpdatedBy:
		return m.UpdatedBy()
	case accountproject.FieldDeletedAt:
		return m.DeletedAt()
	case accountproject.FieldDeletedBy:
		return m.DeletedBy()
	case accountproject.FieldUserID:
		return m.UserID()
	case accountproject.FieldExperienceID:
		return m.ExperienceID()
	case accountproject.FieldTitle:
		return m.Title()
	case accountproject.FieldDescription:
		return m.Description()
	case accountproject.FieldSkills:
		return m.Skills()
	case accountproject.FieldStart:
		return m.Start()
	case accountproject.FieldEnd:
		return m.End()
	case accountproject.FieldLink:
		return m.Link()
	case accountproject.FieldPhotos:
		return m.Photos()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountproject.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case accountproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountproject.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case accountproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountproject.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case accountproject.FieldUserID:
		return m.OldUserID(ctx)
	case accountproject.FieldExperienceID:
		return m.OldExperienceID(ctx)
	case accountproject.FieldTitle:
		return m.OldTitle(ctx)
	case accountproject.FieldDescription:
		return m.OldDescription(ctx)
	case accountproject.FieldSkills:
		return m.OldSkills(ctx)
	case accountproject.FieldStart:
		return m.OldStart(ctx)
	case accountproject.FieldEnd:
		return m.OldEnd(ctx)
	case accountproject.FieldLink:
		return m.OldLink(ctx)
	case accountproject.FieldPhotos:
		return m.OldPhotos(ctx)
	}
	return nil, fmt.Errorf("unknown AccountProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case accountproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case accountproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case accountproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accountproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceID(v)
		return nil
	case accountproject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case accountproject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accountproject.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case accountproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case accountproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case accountproject.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case accountproject.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	}
	return fmt.Errorf("unknown AccountProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountProjectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, accountproject.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, accountproject.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, accountproject.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, accountproject.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, accountproject.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, accountproject.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, accountproject.FieldUserID)
	}
	if m.addexperience_id != nil {
		fields = append(fields, accountproject.FieldExperienceID)
	}
	if m.addstart != nil {
		fields = append(fields, accountproject.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, accountproject.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountproject.FieldCreatedAt:
		return m.AddedCreatedAt()
	case accountproject.FieldCreatedBy:
		return m.AddedCreatedBy()
	case accountproject.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case accountproject.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case accountproject.FieldDeletedAt:
		return m.AddedDeletedAt()
	case accountproject.FieldDeletedBy:
		return m.AddedDeletedBy()
	case accountproject.FieldUserID:
		return m.AddedUserID()
	case accountproject.FieldExperienceID:
		return m.AddedExperienceID()
	case accountproject.FieldStart:
		return m.AddedStart()
	case accountproject.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case accountproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case accountproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case accountproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case accountproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case accountproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case accountproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case accountproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperienceID(v)
		return nil
	case accountproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case accountproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown AccountProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountProjectMutation) ResetField(name string) error {
	switch name {
	case accountproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountproject.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case accountproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountproject.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case accountproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountproject.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case accountproject.FieldUserID:
		m.ResetUserID()
		return nil
	case accountproject.FieldExperienceID:
		m.ResetExperienceID()
		return nil
	case accountproject.FieldTitle:
		m.ResetTitle()
		return nil
	case accountproject.FieldDescription:
		m.ResetDescription()
		return nil
	case accountproject.FieldSkills:
		m.ResetSkills()
		return nil
	case accountproject.FieldStart:
		m.ResetStart()
		return nil
	case accountproject.FieldEnd:
		m.ResetEnd()
		return nil
	case accountproject.FieldLink:
		m.ResetLink()
		return nil
	case accountproject.FieldPhotos:
		m.ResetPhotos()
		return nil
	}
	return fmt.Errorf("unknown AccountProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccountProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccountProject edge %s", name)
}

// BlogsMutation represents an operation that mutates the Blogs nodes in the graph.
type BlogsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	title         *string
	description   *string
	is_hidden     *int8
	addis_hidden  *int8
	tags          *[]string
	appendtags    []string
	cover         *string
	files         *[]string
	appendfiles   []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Blogs, error)
	predicates    []predicate.Blogs
}

var _ ent.Mutation = (*BlogsMutation)(nil)

// blogsOption allows management of the mutation configuration using functional options.
type blogsOption func(*BlogsMutation)

// newBlogsMutation creates new mutation for the Blogs entity.
func newBlogsMutation(c config, op Op, opts ...blogsOption) *BlogsMutation {
	m := &BlogsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsID sets the ID field of the mutation.
func withBlogsID(id int) blogsOption {
	return func(m *BlogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Blogs
		)
		m.oldValue = func(ctx context.Context) (*Blogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogs sets the old Blogs of the mutation.
func withBlogs(node *Blogs) blogsOption {
	return func(m *BlogsMutation) {
		m.oldValue = func(context.Context) (*Blogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blogs entities.
func (m *BlogsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTitle sets the "title" field.
func (m *BlogsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlogsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogsMutation) ResetDescription() {
	m.description = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *BlogsMutation) SetIsHidden(i int8) {
	m.is_hidden = &i
	m.addis_hidden = nil
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *BlogsMutation) IsHidden() (r int8, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldIsHidden(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// AddIsHidden adds i to the "is_hidden" field.
func (m *BlogsMutation) AddIsHidden(i int8) {
	if m.addis_hidden != nil {
		*m.addis_hidden += i
	} else {
		m.addis_hidden = &i
	}
}

// AddedIsHidden returns the value that was added to the "is_hidden" field in this mutation.
func (m *BlogsMutation) AddedIsHidden() (r int8, exists bool) {
	v := m.addis_hidden
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *BlogsMutation) ResetIsHidden() {
	m.is_hidden = nil
	m.addis_hidden = nil
}

// SetTags sets the "tags" field.
func (m *BlogsMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *BlogsMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *BlogsMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *BlogsMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *BlogsMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCover sets the "cover" field.
func (m *BlogsMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *BlogsMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *BlogsMutation) ResetCover() {
	m.cover = nil
}

// SetFiles sets the "files" field.
func (m *BlogsMutation) SetFiles(s []string) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *BlogsMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *BlogsMutation) AppendFiles(s []string) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *BlogsMutation) AppendedFiles() ([]string, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ResetFiles resets all changes to the "files" field.
func (m *BlogsMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
}

// Where appends a list predicates to the BlogsMutation builder.
func (m *BlogsMutation) Where(ps ...predicate.Blogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blogs).
func (m *BlogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.title != nil {
		fields = append(fields, blogs.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blogs.FieldDescription)
	}
	if m.is_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	if m.tags != nil {
		fields = append(fields, blogs.FieldTags)
	}
	if m.cover != nil {
		fields = append(fields, blogs.FieldCover)
	}
	if m.files != nil {
		fields = append(fields, blogs.FieldFiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.CreatedAt()
	case blogs.FieldCreatedBy:
		return m.CreatedBy()
	case blogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogs.FieldDeletedAt:
		return m.DeletedAt()
	case blogs.FieldDeletedBy:
		return m.DeletedBy()
	case blogs.FieldAccountID:
		return m.AccountID()
	case blogs.FieldTitle:
		return m.Title()
	case blogs.FieldDescription:
		return m.Description()
	case blogs.FieldIsHidden:
		return m.IsHidden()
	case blogs.FieldTags:
		return m.Tags()
	case blogs.FieldCover:
		return m.Cover()
	case blogs.FieldFiles:
		return m.Files()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogs.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogs.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogs.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogs.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogs.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogs.FieldTitle:
		return m.OldTitle(ctx)
	case blogs.FieldDescription:
		return m.OldDescription(ctx)
	case blogs.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case blogs.FieldTags:
		return m.OldTags(ctx)
	case blogs.FieldCover:
		return m.OldCover(ctx)
	case blogs.FieldFiles:
		return m.OldFiles(ctx)
	}
	return nil, fmt.Errorf("unknown Blogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogs.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogs.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case blogs.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case blogs.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case blogs.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.addis_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogs.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogs.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogs.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogs.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogs.FieldAccountID:
		return m.AddedAccountID()
	case blogs.FieldIsHidden:
		return m.AddedIsHidden()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsMutation) ResetField(name string) error {
	switch name {
	case blogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogs.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogs.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogs.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogs.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogs.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogs.FieldTitle:
		m.ResetTitle()
		return nil
	case blogs.FieldDescription:
		m.ResetDescription()
		return nil
	case blogs.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case blogs.FieldTags:
		m.ResetTags()
		return nil
	case blogs.FieldCover:
		m.ResetCover()
		return nil
	case blogs.FieldFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blogs edge %s", name)
}

// BlogsCommentMutation represents an operation that mutates the BlogsComment nodes in the graph.
type BlogsCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	blog_id       *int
	addblog_id    *int
	top_id        *int
	addtop_id     *int
	parent_id     *int
	addparent_id  *int
	level         *int
	addlevel      *int
	total         *int
	addtotal      *int
	status        *int8
	addstatus     *int8
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsComment, error)
	predicates    []predicate.BlogsComment
}

var _ ent.Mutation = (*BlogsCommentMutation)(nil)

// blogscommentOption allows management of the mutation configuration using functional options.
type blogscommentOption func(*BlogsCommentMutation)

// newBlogsCommentMutation creates new mutation for the BlogsComment entity.
func newBlogsCommentMutation(c config, op Op, opts ...blogscommentOption) *BlogsCommentMutation {
	m := &BlogsCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsCommentID sets the ID field of the mutation.
func withBlogsCommentID(id int) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsComment
		)
		m.oldValue = func(ctx context.Context) (*BlogsComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsComment sets the old BlogsComment of the mutation.
func withBlogsComment(node *BlogsComment) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		m.oldValue = func(context.Context) (*BlogsComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsComment entities.
func (m *BlogsCommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsCommentMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsCommentMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsCommentMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsCommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsCommentMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsCommentMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsCommentMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsCommentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsCommentMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsCommentMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsCommentMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsCommentMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsCommentMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsCommentMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsCommentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsCommentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsCommentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsCommentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsCommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsCommentMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsCommentMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsCommentMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsCommentMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsCommentMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsCommentMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsCommentMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsCommentMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsCommentMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetBlogID sets the "blog_id" field.
func (m *BlogsCommentMutation) SetBlogID(i int) {
	m.blog_id = &i
	m.addblog_id = nil
}

// BlogID returns the value of the "blog_id" field in the mutation.
func (m *BlogsCommentMutation) BlogID() (r int, exists bool) {
	v := m.blog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogID returns the old "blog_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldBlogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogID: %w", err)
	}
	return oldValue.BlogID, nil
}

// AddBlogID adds i to the "blog_id" field.
func (m *BlogsCommentMutation) AddBlogID(i int) {
	if m.addblog_id != nil {
		*m.addblog_id += i
	} else {
		m.addblog_id = &i
	}
}

// AddedBlogID returns the value that was added to the "blog_id" field in this mutation.
func (m *BlogsCommentMutation) AddedBlogID() (r int, exists bool) {
	v := m.addblog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogID resets all changes to the "blog_id" field.
func (m *BlogsCommentMutation) ResetBlogID() {
	m.blog_id = nil
	m.addblog_id = nil
}

// SetTopID sets the "top_id" field.
func (m *BlogsCommentMutation) SetTopID(i int) {
	m.top_id = &i
	m.addtop_id = nil
}

// TopID returns the value of the "top_id" field in the mutation.
func (m *BlogsCommentMutation) TopID() (r int, exists bool) {
	v := m.top_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopID returns the old "top_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopID: %w", err)
	}
	return oldValue.TopID, nil
}

// AddTopID adds i to the "top_id" field.
func (m *BlogsCommentMutation) AddTopID(i int) {
	if m.addtop_id != nil {
		*m.addtop_id += i
	} else {
		m.addtop_id = &i
	}
}

// AddedTopID returns the value that was added to the "top_id" field in this mutation.
func (m *BlogsCommentMutation) AddedTopID() (r int, exists bool) {
	v := m.addtop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopID resets all changes to the "top_id" field.
func (m *BlogsCommentMutation) ResetTopID() {
	m.top_id = nil
	m.addtop_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *BlogsCommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BlogsCommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *BlogsCommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *BlogsCommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BlogsCommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetLevel sets the "level" field.
func (m *BlogsCommentMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *BlogsCommentMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *BlogsCommentMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *BlogsCommentMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *BlogsCommentMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetTotal sets the "total" field.
func (m *BlogsCommentMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *BlogsCommentMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *BlogsCommentMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *BlogsCommentMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *BlogsCommentMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetStatus sets the "status" field.
func (m *BlogsCommentMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogsCommentMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BlogsCommentMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BlogsCommentMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogsCommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetContent sets the "content" field.
func (m *BlogsCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsCommentMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the BlogsCommentMutation builder.
func (m *BlogsCommentMutation) Where(ps ...predicate.BlogsComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsComment).
func (m *BlogsCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsCommentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.blog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.top_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.parent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.level != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.total != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.status != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, blogscomment.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.CreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.CreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.DeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.DeletedBy()
	case blogscomment.FieldAccountID:
		return m.AccountID()
	case blogscomment.FieldBlogID:
		return m.BlogID()
	case blogscomment.FieldTopID:
		return m.TopID()
	case blogscomment.FieldParentID:
		return m.ParentID()
	case blogscomment.FieldLevel:
		return m.Level()
	case blogscomment.FieldTotal:
		return m.Total()
	case blogscomment.FieldStatus:
		return m.Status()
	case blogscomment.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogscomment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogscomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogscomment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogscomment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogscomment.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogscomment.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogscomment.FieldBlogID:
		return m.OldBlogID(ctx)
	case blogscomment.FieldTopID:
		return m.OldTopID(ctx)
	case blogscomment.FieldParentID:
		return m.OldParentID(ctx)
	case blogscomment.FieldLevel:
		return m.OldLevel(ctx)
	case blogscomment.FieldTotal:
		return m.OldTotal(ctx)
	case blogscomment.FieldStatus:
		return m.OldStatus(ctx)
	case blogscomment.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogscomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsCommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.addblog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.addtop_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.addparent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.addlevel != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.addtotal != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.addstatus != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogscomment.FieldAccountID:
		return m.AddedAccountID()
	case blogscomment.FieldBlogID:
		return m.AddedBlogID()
	case blogscomment.FieldTopID:
		return m.AddedTopID()
	case blogscomment.FieldParentID:
		return m.AddedParentID()
	case blogscomment.FieldLevel:
		return m.AddedLevel()
	case blogscomment.FieldTotal:
		return m.AddedTotal()
	case blogscomment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ResetField(name string) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogscomment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogscomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogscomment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogscomment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogscomment.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogscomment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogscomment.FieldBlogID:
		m.ResetBlogID()
		return nil
	case blogscomment.FieldTopID:
		m.ResetTopID()
		return nil
	case blogscomment.FieldParentID:
		m.ResetParentID()
		return nil
	case blogscomment.FieldLevel:
		m.ResetLevel()
		return nil
	case blogscomment.FieldTotal:
		m.ResetTotal()
		return nil
	case blogscomment.FieldStatus:
		m.ResetStatus()
		return nil
	case blogscomment.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsCommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsCommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsCommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsCommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment edge %s", name)
}

// BlogsContentMutation represents an operation that mutates the BlogsContent nodes in the graph.
type BlogsContentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsContent, error)
	predicates    []predicate.BlogsContent
}

var _ ent.Mutation = (*BlogsContentMutation)(nil)

// blogscontentOption allows management of the mutation configuration using functional options.
type blogscontentOption func(*BlogsContentMutation)

// newBlogsContentMutation creates new mutation for the BlogsContent entity.
func newBlogsContentMutation(c config, op Op, opts ...blogscontentOption) *BlogsContentMutation {
	m := &BlogsContentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsContentID sets the ID field of the mutation.
func withBlogsContentID(id int) blogscontentOption {
	return func(m *BlogsContentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsContent
		)
		m.oldValue = func(ctx context.Context) (*BlogsContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsContent sets the old BlogsContent of the mutation.
func withBlogsContent(node *BlogsContent) blogscontentOption {
	return func(m *BlogsContentMutation) {
		m.oldValue = func(context.Context) (*BlogsContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsContent entities.
func (m *BlogsContentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsContentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsContentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *BlogsContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsContent entity.
// If the BlogsContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsContentMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the BlogsContentMutation builder.
func (m *BlogsContentMutation) Where(ps ...predicate.BlogsContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsContent).
func (m *BlogsContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsContentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, blogscontent.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscontent.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscontent.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogsContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsContentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsContentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsContentMutation) ResetField(name string) error {
	switch name {
	case blogscontent.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsContentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsContentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsContentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsContentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent edge %s", name)
}

// FilesMutation represents an operation that mutates the Files nodes in the graph.
type FilesMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	_type         *string
	size          *int64
	addsize       *int64
	name          *string
	_path         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Files, error)
	predicates    []predicate.Files
}

var _ ent.Mutation = (*FilesMutation)(nil)

// filesOption allows management of the mutation configuration using functional options.
type filesOption func(*FilesMutation)

// newFilesMutation creates new mutation for the Files entity.
func newFilesMutation(c config, op Op, opts ...filesOption) *FilesMutation {
	m := &FilesMutation{
		config:        c,
		op:            op,
		typ:           TypeFiles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesID sets the ID field of the mutation.
func withFilesID(id string) filesOption {
	return func(m *FilesMutation) {
		var (
			err   error
			once  sync.Once
			value *Files
		)
		m.oldValue = func(ctx context.Context) (*Files, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Files.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFiles sets the old Files of the mutation.
func withFiles(node *Files) filesOption {
	return func(m *FilesMutation) {
		m.oldValue = func(context.Context) (*Files, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Files entities.
func (m *FilesMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Files.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetType sets the "type" field.
func (m *FilesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FilesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FilesMutation) ResetType() {
	m._type = nil
}

// SetSize sets the "size" field.
func (m *FilesMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FilesMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FilesMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FilesMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FilesMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetName sets the "name" field.
func (m *FilesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FilesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FilesMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FilesMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FilesMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FilesMutation) ResetPath() {
	m._path = nil
}

// Where appends a list predicates to the FilesMutation builder.
func (m *FilesMutation) Where(ps ...predicate.Files) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Files, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Files).
func (m *FilesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m._type != nil {
		fields = append(fields, files.FieldType)
	}
	if m.size != nil {
		fields = append(fields, files.FieldSize)
	}
	if m.name != nil {
		fields = append(fields, files.FieldName)
	}
	if m._path != nil {
		fields = append(fields, files.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.CreatedAt()
	case files.FieldCreatedBy:
		return m.CreatedBy()
	case files.FieldUpdatedAt:
		return m.UpdatedAt()
	case files.FieldUpdatedBy:
		return m.UpdatedBy()
	case files.FieldDeletedAt:
		return m.DeletedAt()
	case files.FieldDeletedBy:
		return m.DeletedBy()
	case files.FieldType:
		return m.GetType()
	case files.FieldSize:
		return m.Size()
	case files.FieldName:
		return m.Name()
	case files.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case files.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case files.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case files.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case files.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case files.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case files.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case files.FieldType:
		return m.OldType(ctx)
	case files.FieldSize:
		return m.OldSize(ctx)
	case files.FieldName:
		return m.OldName(ctx)
	case files.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Files field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case files.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case files.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case files.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m.addsize != nil {
		fields = append(fields, files.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.AddedCreatedAt()
	case files.FieldCreatedBy:
		return m.AddedCreatedBy()
	case files.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case files.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case files.FieldDeletedAt:
		return m.AddedDeletedAt()
	case files.FieldDeletedBy:
		return m.AddedDeletedBy()
	case files.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Files numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Files nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesMutation) ResetField(name string) error {
	switch name {
	case files.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case files.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case files.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case files.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case files.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case files.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case files.FieldType:
		m.ResetType()
		return nil
	case files.FieldSize:
		m.ResetSize()
		return nil
	case files.FieldName:
		m.ResetName()
		return nil
	case files.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Files unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Files edge %s", name)
}

// FilesExtendMutation represents an operation that mutates the FilesExtend nodes in the graph.
type FilesExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	file_id       *string
	user_id       *int
	adduser_id    *int
	filename      *string
	from          *string
	is_hidden     *int8
	addis_hidden  *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FilesExtend, error)
	predicates    []predicate.FilesExtend
}

var _ ent.Mutation = (*FilesExtendMutation)(nil)

// filesextendOption allows management of the mutation configuration using functional options.
type filesextendOption func(*FilesExtendMutation)

// newFilesExtendMutation creates new mutation for the FilesExtend entity.
func newFilesExtendMutation(c config, op Op, opts ...filesextendOption) *FilesExtendMutation {
	m := &FilesExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeFilesExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesExtendID sets the ID field of the mutation.
func withFilesExtendID(id int) filesextendOption {
	return func(m *FilesExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *FilesExtend
		)
		m.oldValue = func(ctx context.Context) (*FilesExtend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilesExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilesExtend sets the old FilesExtend of the mutation.
func withFilesExtend(node *FilesExtend) filesextendOption {
	return func(m *FilesExtendMutation) {
		m.oldValue = func(context.Context) (*FilesExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FilesExtend entities.
func (m *FilesExtendMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesExtendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesExtendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilesExtend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesExtendMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesExtendMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesExtendMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesExtendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesExtendMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesExtendMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesExtendMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesExtendMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesExtendMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesExtendMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesExtendMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesExtendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesExtendMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesExtendMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesExtendMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesExtendMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesExtendMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesExtendMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesExtendMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesExtendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesExtendMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesExtendMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesExtendMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesExtendMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetFileID sets the "file_id" field.
func (m *FilesExtendMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FilesExtendMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FilesExtendMutation) ResetFileID() {
	m.file_id = nil
}

// SetUserID sets the "user_id" field.
func (m *FilesExtendMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FilesExtendMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FilesExtendMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FilesExtendMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FilesExtendMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetFilename sets the "filename" field.
func (m *FilesExtendMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *FilesExtendMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *FilesExtendMutation) ResetFilename() {
	m.filename = nil
}

// SetFrom sets the "from" field.
func (m *FilesExtendMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *FilesExtendMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *FilesExtendMutation) ResetFrom() {
	m.from = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *FilesExtendMutation) SetIsHidden(i int8) {
	m.is_hidden = &i
	m.addis_hidden = nil
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *FilesExtendMutation) IsHidden() (r int8, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldIsHidden(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// AddIsHidden adds i to the "is_hidden" field.
func (m *FilesExtendMutation) AddIsHidden(i int8) {
	if m.addis_hidden != nil {
		*m.addis_hidden += i
	} else {
		m.addis_hidden = &i
	}
}

// AddedIsHidden returns the value that was added to the "is_hidden" field in this mutation.
func (m *FilesExtendMutation) AddedIsHidden() (r int8, exists bool) {
	v := m.addis_hidden
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *FilesExtendMutation) ResetIsHidden() {
	m.is_hidden = nil
	m.addis_hidden = nil
}

// Where appends a list predicates to the FilesExtendMutation builder.
func (m *FilesExtendMutation) Where(ps ...predicate.FilesExtend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesExtendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesExtendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FilesExtend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesExtendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesExtendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FilesExtend).
func (m *FilesExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesExtendMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.file_id != nil {
		fields = append(fields, filesextend.FieldFileID)
	}
	if m.user_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.filename != nil {
		fields = append(fields, filesextend.FieldFilename)
	}
	if m.from != nil {
		fields = append(fields, filesextend.FieldFrom)
	}
	if m.is_hidden != nil {
		fields = append(fields, filesextend.FieldIsHidden)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.CreatedAt()
	case filesextend.FieldCreatedBy:
		return m.CreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.UpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.UpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.DeletedAt()
	case filesextend.FieldDeletedBy:
		return m.DeletedBy()
	case filesextend.FieldFileID:
		return m.FileID()
	case filesextend.FieldUserID:
		return m.UserID()
	case filesextend.FieldFilename:
		return m.Filename()
	case filesextend.FieldFrom:
		return m.From()
	case filesextend.FieldIsHidden:
		return m.IsHidden()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filesextend.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filesextend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filesextend.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filesextend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case filesextend.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case filesextend.FieldFileID:
		return m.OldFileID(ctx)
	case filesextend.FieldUserID:
		return m.OldUserID(ctx)
	case filesextend.FieldFilename:
		return m.OldFilename(ctx)
	case filesextend.FieldFrom:
		return m.OldFrom(ctx)
	case filesextend.FieldIsHidden:
		return m.OldIsHidden(ctx)
	}
	return nil, fmt.Errorf("unknown FilesExtend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case filesextend.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case filesextend.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case filesextend.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case filesextend.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesExtendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.addis_hidden != nil {
		fields = append(fields, filesextend.FieldIsHidden)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesExtendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case filesextend.FieldCreatedBy:
		return m.AddedCreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.AddedDeletedAt()
	case filesextend.FieldDeletedBy:
		return m.AddedDeletedBy()
	case filesextend.FieldUserID:
		return m.AddedUserID()
	case filesextend.FieldIsHidden:
		return m.AddedIsHidden()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case filesextend.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesExtendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesExtendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FilesExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesExtendMutation) ResetField(name string) error {
	switch name {
	case filesextend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filesextend.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filesextend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filesextend.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filesextend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case filesextend.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case filesextend.FieldFileID:
		m.ResetFileID()
		return nil
	case filesextend.FieldUserID:
		m.ResetUserID()
		return nil
	case filesextend.FieldFilename:
		m.ResetFilename()
		return nil
	case filesextend.FieldFrom:
		m.ResetFrom()
		return nil
	case filesextend.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesExtendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesExtendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesExtendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FilesExtend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesExtendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FilesExtend edge %s", name)
}

// TravelMutation represents an operation that mutates the Travel nodes in the graph.
type TravelMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	title          *string
	description    *string
	video          *string
	photos         *[]string
	appendphotos   []string
	browse_num     *int
	addbrowse_num  *int
	thumb_num      *int
	addthumb_num   *int
	collect_num    *int
	addcollect_num *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Travel, error)
	predicates     []predicate.Travel
}

var _ ent.Mutation = (*TravelMutation)(nil)

// travelOption allows management of the mutation configuration using functional options.
type travelOption func(*TravelMutation)

// newTravelMutation creates new mutation for the Travel entity.
func newTravelMutation(c config, op Op, opts ...travelOption) *TravelMutation {
	m := &TravelMutation{
		config:        c,
		op:            op,
		typ:           TypeTravel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelID sets the ID field of the mutation.
func withTravelID(id int) travelOption {
	return func(m *TravelMutation) {
		var (
			err   error
			once  sync.Once
			value *Travel
		)
		m.oldValue = func(ctx context.Context) (*Travel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Travel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravel sets the old Travel of the mutation.
func withTravel(node *Travel) travelOption {
	return func(m *TravelMutation) {
		m.oldValue = func(context.Context) (*Travel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Travel entities.
func (m *TravelMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Travel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetTitle sets the "title" field.
func (m *TravelMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TravelMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TravelMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TravelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TravelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TravelMutation) ResetDescription() {
	m.description = nil
}

// SetVideo sets the "video" field.
func (m *TravelMutation) SetVideo(s string) {
	m.video = &s
}

// Video returns the value of the "video" field in the mutation.
func (m *TravelMutation) Video() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideo returns the old "video" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldVideo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideo: %w", err)
	}
	return oldValue.Video, nil
}

// ResetVideo resets all changes to the "video" field.
func (m *TravelMutation) ResetVideo() {
	m.video = nil
}

// SetPhotos sets the "photos" field.
func (m *TravelMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *TravelMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *TravelMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *TravelMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *TravelMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// SetBrowseNum sets the "browse_num" field.
func (m *TravelMutation) SetBrowseNum(i int) {
	m.browse_num = &i
	m.addbrowse_num = nil
}

// BrowseNum returns the value of the "browse_num" field in the mutation.
func (m *TravelMutation) BrowseNum() (r int, exists bool) {
	v := m.browse_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseNum returns the old "browse_num" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldBrowseNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseNum: %w", err)
	}
	return oldValue.BrowseNum, nil
}

// AddBrowseNum adds i to the "browse_num" field.
func (m *TravelMutation) AddBrowseNum(i int) {
	if m.addbrowse_num != nil {
		*m.addbrowse_num += i
	} else {
		m.addbrowse_num = &i
	}
}

// AddedBrowseNum returns the value that was added to the "browse_num" field in this mutation.
func (m *TravelMutation) AddedBrowseNum() (r int, exists bool) {
	v := m.addbrowse_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseNum resets all changes to the "browse_num" field.
func (m *TravelMutation) ResetBrowseNum() {
	m.browse_num = nil
	m.addbrowse_num = nil
}

// SetThumbNum sets the "thumb_num" field.
func (m *TravelMutation) SetThumbNum(i int) {
	m.thumb_num = &i
	m.addthumb_num = nil
}

// ThumbNum returns the value of the "thumb_num" field in the mutation.
func (m *TravelMutation) ThumbNum() (r int, exists bool) {
	v := m.thumb_num
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbNum returns the old "thumb_num" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldThumbNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbNum: %w", err)
	}
	return oldValue.ThumbNum, nil
}

// AddThumbNum adds i to the "thumb_num" field.
func (m *TravelMutation) AddThumbNum(i int) {
	if m.addthumb_num != nil {
		*m.addthumb_num += i
	} else {
		m.addthumb_num = &i
	}
}

// AddedThumbNum returns the value that was added to the "thumb_num" field in this mutation.
func (m *TravelMutation) AddedThumbNum() (r int, exists bool) {
	v := m.addthumb_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetThumbNum resets all changes to the "thumb_num" field.
func (m *TravelMutation) ResetThumbNum() {
	m.thumb_num = nil
	m.addthumb_num = nil
}

// SetCollectNum sets the "collect_num" field.
func (m *TravelMutation) SetCollectNum(i int) {
	m.collect_num = &i
	m.addcollect_num = nil
}

// CollectNum returns the value of the "collect_num" field in the mutation.
func (m *TravelMutation) CollectNum() (r int, exists bool) {
	v := m.collect_num
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectNum returns the old "collect_num" field's value of the Travel entity.
// If the Travel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelMutation) OldCollectNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectNum: %w", err)
	}
	return oldValue.CollectNum, nil
}

// AddCollectNum adds i to the "collect_num" field.
func (m *TravelMutation) AddCollectNum(i int) {
	if m.addcollect_num != nil {
		*m.addcollect_num += i
	} else {
		m.addcollect_num = &i
	}
}

// AddedCollectNum returns the value that was added to the "collect_num" field in this mutation.
func (m *TravelMutation) AddedCollectNum() (r int, exists bool) {
	v := m.addcollect_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectNum resets all changes to the "collect_num" field.
func (m *TravelMutation) ResetCollectNum() {
	m.collect_num = nil
	m.addcollect_num = nil
}

// Where appends a list predicates to the TravelMutation builder.
func (m *TravelMutation) Where(ps ...predicate.Travel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Travel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Travel).
func (m *TravelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, travel.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travel.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travel.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travel.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travel.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travel.FieldDeletedBy)
	}
	if m.title != nil {
		fields = append(fields, travel.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, travel.FieldDescription)
	}
	if m.video != nil {
		fields = append(fields, travel.FieldVideo)
	}
	if m.photos != nil {
		fields = append(fields, travel.FieldPhotos)
	}
	if m.browse_num != nil {
		fields = append(fields, travel.FieldBrowseNum)
	}
	if m.thumb_num != nil {
		fields = append(fields, travel.FieldThumbNum)
	}
	if m.collect_num != nil {
		fields = append(fields, travel.FieldCollectNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travel.FieldCreatedAt:
		return m.CreatedAt()
	case travel.FieldCreatedBy:
		return m.CreatedBy()
	case travel.FieldUpdatedAt:
		return m.UpdatedAt()
	case travel.FieldUpdatedBy:
		return m.UpdatedBy()
	case travel.FieldDeletedAt:
		return m.DeletedAt()
	case travel.FieldDeletedBy:
		return m.DeletedBy()
	case travel.FieldTitle:
		return m.Title()
	case travel.FieldDescription:
		return m.Description()
	case travel.FieldVideo:
		return m.Video()
	case travel.FieldPhotos:
		return m.Photos()
	case travel.FieldBrowseNum:
		return m.BrowseNum()
	case travel.FieldThumbNum:
		return m.ThumbNum()
	case travel.FieldCollectNum:
		return m.CollectNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travel.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travel.FieldTitle:
		return m.OldTitle(ctx)
	case travel.FieldDescription:
		return m.OldDescription(ctx)
	case travel.FieldVideo:
		return m.OldVideo(ctx)
	case travel.FieldPhotos:
		return m.OldPhotos(ctx)
	case travel.FieldBrowseNum:
		return m.OldBrowseNum(ctx)
	case travel.FieldThumbNum:
		return m.OldThumbNum(ctx)
	case travel.FieldCollectNum:
		return m.OldCollectNum(ctx)
	}
	return nil, fmt.Errorf("unknown Travel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travel.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travel.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travel.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travel.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travel.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travel.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travel.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case travel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case travel.FieldVideo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideo(v)
		return nil
	case travel.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	case travel.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseNum(v)
		return nil
	case travel.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbNum(v)
		return nil
	case travel.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travel.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travel.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travel.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travel.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travel.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travel.FieldDeletedBy)
	}
	if m.addbrowse_num != nil {
		fields = append(fields, travel.FieldBrowseNum)
	}
	if m.addthumb_num != nil {
		fields = append(fields, travel.FieldThumbNum)
	}
	if m.addcollect_num != nil {
		fields = append(fields, travel.FieldCollectNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travel.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travel.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travel.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travel.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travel.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travel.FieldBrowseNum:
		return m.AddedBrowseNum()
	case travel.FieldThumbNum:
		return m.AddedThumbNum()
	case travel.FieldCollectNum:
		return m.AddedCollectNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travel.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travel.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travel.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travel.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travel.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travel.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travel.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseNum(v)
		return nil
	case travel.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbNum(v)
		return nil
	case travel.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Travel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelMutation) ResetField(name string) error {
	switch name {
	case travel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travel.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travel.FieldTitle:
		m.ResetTitle()
		return nil
	case travel.FieldDescription:
		m.ResetDescription()
		return nil
	case travel.FieldVideo:
		m.ResetVideo()
		return nil
	case travel.FieldPhotos:
		m.ResetPhotos()
		return nil
	case travel.FieldBrowseNum:
		m.ResetBrowseNum()
		return nil
	case travel.FieldThumbNum:
		m.ResetThumbNum()
		return nil
	case travel.FieldCollectNum:
		m.ResetCollectNum()
		return nil
	}
	return fmt.Errorf("unknown Travel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Travel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Travel edge %s", name)
}

// TravelExtendMutation represents an operation that mutates the TravelExtend nodes in the graph.
type TravelExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	travel_id     *int
	addtravel_id  *int
	is_thumb      *bool
	is_collect    *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TravelExtend, error)
	predicates    []predicate.TravelExtend
}

var _ ent.Mutation = (*TravelExtendMutation)(nil)

// travelextendOption allows management of the mutation configuration using functional options.
type travelextendOption func(*TravelExtendMutation)

// newTravelExtendMutation creates new mutation for the TravelExtend entity.
func newTravelExtendMutation(c config, op Op, opts ...travelextendOption) *TravelExtendMutation {
	m := &TravelExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeTravelExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelExtendID sets the ID field of the mutation.
func withTravelExtendID(id int) travelextendOption {
	return func(m *TravelExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *TravelExtend
		)
		m.oldValue = func(ctx context.Context) (*TravelExtend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TravelExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravelExtend sets the old TravelExtend of the mutation.
func withTravelExtend(node *TravelExtend) travelextendOption {
	return func(m *TravelExtendMutation) {
		m.oldValue = func(context.Context) (*TravelExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelExtendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelExtendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TravelExtend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelExtendMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelExtendMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelExtendMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelExtendMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelExtendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelExtendMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelExtendMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelExtendMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelExtendMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelExtendMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelExtendMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelExtendMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelExtendMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelExtendMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelExtendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelExtendMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelExtendMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelExtendMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelExtendMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelExtendMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelExtendMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelExtendMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelExtendMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelExtendMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelExtendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelExtendMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelExtendMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelExtendMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelExtendMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelExtendMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *TravelExtendMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TravelExtendMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *TravelExtendMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *TravelExtendMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TravelExtendMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTravelID sets the "travel_id" field.
func (m *TravelExtendMutation) SetTravelID(i int) {
	m.travel_id = &i
	m.addtravel_id = nil
}

// TravelID returns the value of the "travel_id" field in the mutation.
func (m *TravelExtendMutation) TravelID() (r int, exists bool) {
	v := m.travel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTravelID returns the old "travel_id" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldTravelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTravelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTravelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTravelID: %w", err)
	}
	return oldValue.TravelID, nil
}

// AddTravelID adds i to the "travel_id" field.
func (m *TravelExtendMutation) AddTravelID(i int) {
	if m.addtravel_id != nil {
		*m.addtravel_id += i
	} else {
		m.addtravel_id = &i
	}
}

// AddedTravelID returns the value that was added to the "travel_id" field in this mutation.
func (m *TravelExtendMutation) AddedTravelID() (r int, exists bool) {
	v := m.addtravel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTravelID resets all changes to the "travel_id" field.
func (m *TravelExtendMutation) ResetTravelID() {
	m.travel_id = nil
	m.addtravel_id = nil
}

// SetIsThumb sets the "is_thumb" field.
func (m *TravelExtendMutation) SetIsThumb(b bool) {
	m.is_thumb = &b
}

// IsThumb returns the value of the "is_thumb" field in the mutation.
func (m *TravelExtendMutation) IsThumb() (r bool, exists bool) {
	v := m.is_thumb
	if v == nil {
		return
	}
	return *v, true
}

// OldIsThumb returns the old "is_thumb" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldIsThumb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsThumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsThumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsThumb: %w", err)
	}
	return oldValue.IsThumb, nil
}

// ResetIsThumb resets all changes to the "is_thumb" field.
func (m *TravelExtendMutation) ResetIsThumb() {
	m.is_thumb = nil
}

// SetIsCollect sets the "is_collect" field.
func (m *TravelExtendMutation) SetIsCollect(b bool) {
	m.is_collect = &b
}

// IsCollect returns the value of the "is_collect" field in the mutation.
func (m *TravelExtendMutation) IsCollect() (r bool, exists bool) {
	v := m.is_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCollect returns the old "is_collect" field's value of the TravelExtend entity.
// If the TravelExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendMutation) OldIsCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCollect: %w", err)
	}
	return oldValue.IsCollect, nil
}

// ResetIsCollect resets all changes to the "is_collect" field.
func (m *TravelExtendMutation) ResetIsCollect() {
	m.is_collect = nil
}

// Where appends a list predicates to the TravelExtendMutation builder.
func (m *TravelExtendMutation) Where(ps ...predicate.TravelExtend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelExtendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelExtendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TravelExtend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelExtendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelExtendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TravelExtend).
func (m *TravelExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelExtendMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, travelextend.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travelextend.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travelextend.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travelextend.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travelextend.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travelextend.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, travelextend.FieldAccountID)
	}
	if m.travel_id != nil {
		fields = append(fields, travelextend.FieldTravelID)
	}
	if m.is_thumb != nil {
		fields = append(fields, travelextend.FieldIsThumb)
	}
	if m.is_collect != nil {
		fields = append(fields, travelextend.FieldIsCollect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travelextend.FieldCreatedAt:
		return m.CreatedAt()
	case travelextend.FieldCreatedBy:
		return m.CreatedBy()
	case travelextend.FieldUpdatedAt:
		return m.UpdatedAt()
	case travelextend.FieldUpdatedBy:
		return m.UpdatedBy()
	case travelextend.FieldDeletedAt:
		return m.DeletedAt()
	case travelextend.FieldDeletedBy:
		return m.DeletedBy()
	case travelextend.FieldAccountID:
		return m.AccountID()
	case travelextend.FieldTravelID:
		return m.TravelID()
	case travelextend.FieldIsThumb:
		return m.IsThumb()
	case travelextend.FieldIsCollect:
		return m.IsCollect()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travelextend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travelextend.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travelextend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travelextend.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travelextend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travelextend.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travelextend.FieldAccountID:
		return m.OldAccountID(ctx)
	case travelextend.FieldTravelID:
		return m.OldTravelID(ctx)
	case travelextend.FieldIsThumb:
		return m.OldIsThumb(ctx)
	case travelextend.FieldIsCollect:
		return m.OldIsCollect(ctx)
	}
	return nil, fmt.Errorf("unknown TravelExtend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travelextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travelextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travelextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travelextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travelextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travelextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travelextend.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case travelextend.FieldTravelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTravelID(v)
		return nil
	case travelextend.FieldIsThumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsThumb(v)
		return nil
	case travelextend.FieldIsCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCollect(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelExtendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travelextend.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travelextend.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travelextend.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travelextend.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travelextend.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travelextend.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, travelextend.FieldAccountID)
	}
	if m.addtravel_id != nil {
		fields = append(fields, travelextend.FieldTravelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelExtendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travelextend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travelextend.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travelextend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travelextend.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travelextend.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travelextend.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travelextend.FieldAccountID:
		return m.AddedAccountID()
	case travelextend.FieldTravelID:
		return m.AddedTravelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travelextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travelextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travelextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travelextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travelextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travelextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travelextend.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case travelextend.FieldTravelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTravelID(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelExtendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelExtendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TravelExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelExtendMutation) ResetField(name string) error {
	switch name {
	case travelextend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travelextend.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travelextend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travelextend.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travelextend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travelextend.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travelextend.FieldAccountID:
		m.ResetAccountID()
		return nil
	case travelextend.FieldTravelID:
		m.ResetTravelID()
		return nil
	case travelextend.FieldIsThumb:
		m.ResetIsThumb()
		return nil
	case travelextend.FieldIsCollect:
		m.ResetIsCollect()
		return nil
	}
	return fmt.Errorf("unknown TravelExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelExtendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelExtendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelExtendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TravelExtend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelExtendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TravelExtend edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	name          *string
	email         *string
	avatar        *string
	professional  *string
	skills        *[]string
	appendskills  []string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetProfessional sets the "professional" field.
func (m *UserMutation) SetProfessional(s string) {
	m.professional = &s
}

// Professional returns the value of the "professional" field in the mutation.
func (m *UserMutation) Professional() (r string, exists bool) {
	v := m.professional
	if v == nil {
		return
	}
	return *v, true
}

// OldProfessional returns the old "professional" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfessional(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfessional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfessional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfessional: %w", err)
	}
	return oldValue.Professional, nil
}

// ResetProfessional resets all changes to the "professional" field.
func (m *UserMutation) ResetProfessional() {
	m.professional = nil
}

// SetSkills sets the "skills" field.
func (m *UserMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.professional != nil {
		fields = append(fields, user.FieldProfessional)
	}
	if m.skills != nil {
		fields = append(fields, user.FieldSkills)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldProfessional:
		return m.Professional()
	case user.FieldSkills:
		return m.Skills()
	case user.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldProfessional:
		return m.OldProfessional(ctx)
	case user.FieldSkills:
		return m.OldSkills(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldProfessional:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfessional(v)
		return nil
	case user.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.AddedCreatedAt()
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldProfessional:
		m.ResetProfessional()
		return nil
	case user.FieldSkills:
		m.ResetSkills()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
