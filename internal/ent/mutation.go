// Code generated by ent, DO NOT EDIT.

package ent

import (
	"blog/internal/ent/account"
	"blog/internal/ent/blogs"
	"blog/internal/ent/blogscomment"
	"blog/internal/ent/blogscontent"
	"blog/internal/ent/blogsextend"
	"blog/internal/ent/files"
	"blog/internal/ent/filesextend"
	"blog/internal/ent/palacesmemo"
	"blog/internal/ent/palacesmemory"
	"blog/internal/ent/palacestodo"
	"blog/internal/ent/palacestododone"
	"blog/internal/ent/predicate"
	"blog/internal/ent/tags"
	"blog/internal/ent/tagsrelation"
	"blog/internal/ent/travelextends"
	"blog/internal/ent/travels"
	"blog/internal/ent/user"
	"blog/internal/ent/userexperience"
	"blog/internal/ent/userfamousquotes"
	"blog/internal/ent/userproject"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount          = "Account"
	TypeBlogs            = "Blogs"
	TypeBlogsComment     = "BlogsComment"
	TypeBlogsContent     = "BlogsContent"
	TypeBlogsExtend      = "BlogsExtend"
	TypeFiles            = "Files"
	TypeFilesExtend      = "FilesExtend"
	TypePalacesMemo      = "PalacesMemo"
	TypePalacesMemory    = "PalacesMemory"
	TypePalacesTodo      = "PalacesTodo"
	TypePalacesTodoDone  = "PalacesTodoDone"
	TypeTags             = "Tags"
	TypeTagsRelation     = "TagsRelation"
	TypeTravelExtends    = "TravelExtends"
	TypeTravels          = "Travels"
	TypeUser             = "User"
	TypeUserExperience   = "UserExperience"
	TypeUserFamousQuotes = "UserFamousQuotes"
	TypeUserProject      = "UserProject"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	nickname       *string
	account        *string
	password       *string
	email          *string
	description    *string
	avatar         *string
	blog_num       *int
	addblog_num    *int
	status         *int8
	addstatus      *int8
	clearedFields  map[string]struct{}
	travels        map[int]struct{}
	removedtravels map[int]struct{}
	clearedtravels bool
	done           bool
	oldValue       func(context.Context) (*Account, error)
	predicates     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *AccountMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AccountMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *AccountMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AccountMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AccountMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AccountMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
}

// SetAvatar sets the "avatar" field.
func (m *AccountMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AccountMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AccountMutation) ResetAvatar() {
	m.avatar = nil
}

// SetBlogNum sets the "blog_num" field.
func (m *AccountMutation) SetBlogNum(i int) {
	m.blog_num = &i
	m.addblog_num = nil
}

// BlogNum returns the value of the "blog_num" field in the mutation.
func (m *AccountMutation) BlogNum() (r int, exists bool) {
	v := m.blog_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogNum returns the old "blog_num" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBlogNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogNum: %w", err)
	}
	return oldValue.BlogNum, nil
}

// AddBlogNum adds i to the "blog_num" field.
func (m *AccountMutation) AddBlogNum(i int) {
	if m.addblog_num != nil {
		*m.addblog_num += i
	} else {
		m.addblog_num = &i
	}
}

// AddedBlogNum returns the value that was added to the "blog_num" field in this mutation.
func (m *AccountMutation) AddedBlogNum() (r int, exists bool) {
	v := m.addblog_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogNum resets all changes to the "blog_num" field.
func (m *AccountMutation) ResetBlogNum() {
	m.blog_num = nil
	m.addblog_num = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddTravelIDs adds the "travels" edge to the Travels entity by ids.
func (m *AccountMutation) AddTravelIDs(ids ...int) {
	if m.travels == nil {
		m.travels = make(map[int]struct{})
	}
	for i := range ids {
		m.travels[ids[i]] = struct{}{}
	}
}

// ClearTravels clears the "travels" edge to the Travels entity.
func (m *AccountMutation) ClearTravels() {
	m.clearedtravels = true
}

// TravelsCleared reports if the "travels" edge to the Travels entity was cleared.
func (m *AccountMutation) TravelsCleared() bool {
	return m.clearedtravels
}

// RemoveTravelIDs removes the "travels" edge to the Travels entity by IDs.
func (m *AccountMutation) RemoveTravelIDs(ids ...int) {
	if m.removedtravels == nil {
		m.removedtravels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.travels, ids[i])
		m.removedtravels[ids[i]] = struct{}{}
	}
}

// RemovedTravels returns the removed IDs of the "travels" edge to the Travels entity.
func (m *AccountMutation) RemovedTravelsIDs() (ids []int) {
	for id := range m.removedtravels {
		ids = append(ids, id)
	}
	return
}

// TravelsIDs returns the "travels" edge IDs in the mutation.
func (m *AccountMutation) TravelsIDs() (ids []int) {
	for id := range m.travels {
		ids = append(ids, id)
	}
	return
}

// ResetTravels resets all changes to the "travels" edge.
func (m *AccountMutation) ResetTravels() {
	m.travels = nil
	m.clearedtravels = false
	m.removedtravels = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.avatar != nil {
		fields = append(fields, account.FieldAvatar)
	}
	if m.blog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldCreatedBy:
		return m.CreatedBy()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldUpdatedBy:
		return m.UpdatedBy()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldDeletedBy:
		return m.DeletedBy()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldAccount:
		return m.Account()
	case account.FieldPassword:
		return m.Password()
	case account.FieldEmail:
		return m.Email()
	case account.FieldDescription:
		return m.Description()
	case account.FieldAvatar:
		return m.Avatar()
	case account.FieldBlogNum:
		return m.BlogNum()
	case account.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldAvatar:
		return m.OldAvatar(ctx)
	case account.FieldBlogNum:
		return m.OldBlogNum(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.addblog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.AddedCreatedAt()
	case account.FieldCreatedBy:
		return m.AddedCreatedBy()
	case account.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case account.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case account.FieldDeletedAt:
		return m.AddedDeletedAt()
	case account.FieldDeletedBy:
		return m.AddedDeletedBy()
	case account.FieldBlogNum:
		return m.AddedBlogNum()
	case account.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldAvatar:
		m.ResetAvatar()
		return nil
	case account.FieldBlogNum:
		m.ResetBlogNum()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.travels != nil {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTravels:
		ids := make([]ent.Value, 0, len(m.travels))
		for id := range m.travels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtravels != nil {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTravels:
		ids := make([]ent.Value, 0, len(m.removedtravels))
		for id := range m.removedtravels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtravels {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTravels:
		return m.clearedtravels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTravels:
		m.ResetTravels()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// BlogsMutation represents an operation that mutates the Blogs nodes in the graph.
type BlogsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *int64
	addcreated_at       *int64
	created_by          *int64
	addcreated_by       *int64
	updated_at          *int64
	addupdated_at       *int64
	updated_by          *int64
	addupdated_by       *int64
	deleted_at          *int64
	adddeleted_at       *int64
	deleted_by          *int64
	adddeleted_by       *int64
	account_id          *int
	addaccount_id       *int
	title               *string
	description         *string
	is_hidden           *int8
	addis_hidden        *int8
	tags                *[]string
	appendtags          []string
	cover               *string
	browse_num          *int
	addbrowse_num       *int
	collect_num         *int
	addcollect_num      *int
	love_num            *int
	addlove_num         *int
	clearedFields       map[string]struct{}
	tag                 map[int]struct{}
	removedtag          map[int]struct{}
	clearedtag          bool
	tag_relation        map[int]struct{}
	removedtag_relation map[int]struct{}
	clearedtag_relation bool
	done                bool
	oldValue            func(context.Context) (*Blogs, error)
	predicates          []predicate.Blogs
}

var _ ent.Mutation = (*BlogsMutation)(nil)

// blogsOption allows management of the mutation configuration using functional options.
type blogsOption func(*BlogsMutation)

// newBlogsMutation creates new mutation for the Blogs entity.
func newBlogsMutation(c config, op Op, opts ...blogsOption) *BlogsMutation {
	m := &BlogsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsID sets the ID field of the mutation.
func withBlogsID(id int) blogsOption {
	return func(m *BlogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Blogs
		)
		m.oldValue = func(ctx context.Context) (*Blogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogs sets the old Blogs of the mutation.
func withBlogs(node *Blogs) blogsOption {
	return func(m *BlogsMutation) {
		m.oldValue = func(context.Context) (*Blogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blogs entities.
func (m *BlogsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTitle sets the "title" field.
func (m *BlogsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlogsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogsMutation) ResetDescription() {
	m.description = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *BlogsMutation) SetIsHidden(i int8) {
	m.is_hidden = &i
	m.addis_hidden = nil
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *BlogsMutation) IsHidden() (r int8, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldIsHidden(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// AddIsHidden adds i to the "is_hidden" field.
func (m *BlogsMutation) AddIsHidden(i int8) {
	if m.addis_hidden != nil {
		*m.addis_hidden += i
	} else {
		m.addis_hidden = &i
	}
}

// AddedIsHidden returns the value that was added to the "is_hidden" field in this mutation.
func (m *BlogsMutation) AddedIsHidden() (r int8, exists bool) {
	v := m.addis_hidden
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *BlogsMutation) ResetIsHidden() {
	m.is_hidden = nil
	m.addis_hidden = nil
}

// SetTags sets the "tags" field.
func (m *BlogsMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *BlogsMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *BlogsMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *BlogsMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *BlogsMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCover sets the "cover" field.
func (m *BlogsMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *BlogsMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *BlogsMutation) ResetCover() {
	m.cover = nil
}

// SetBrowseNum sets the "browse_num" field.
func (m *BlogsMutation) SetBrowseNum(i int) {
	m.browse_num = &i
	m.addbrowse_num = nil
}

// BrowseNum returns the value of the "browse_num" field in the mutation.
func (m *BlogsMutation) BrowseNum() (r int, exists bool) {
	v := m.browse_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseNum returns the old "browse_num" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldBrowseNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseNum: %w", err)
	}
	return oldValue.BrowseNum, nil
}

// AddBrowseNum adds i to the "browse_num" field.
func (m *BlogsMutation) AddBrowseNum(i int) {
	if m.addbrowse_num != nil {
		*m.addbrowse_num += i
	} else {
		m.addbrowse_num = &i
	}
}

// AddedBrowseNum returns the value that was added to the "browse_num" field in this mutation.
func (m *BlogsMutation) AddedBrowseNum() (r int, exists bool) {
	v := m.addbrowse_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseNum resets all changes to the "browse_num" field.
func (m *BlogsMutation) ResetBrowseNum() {
	m.browse_num = nil
	m.addbrowse_num = nil
}

// SetCollectNum sets the "collect_num" field.
func (m *BlogsMutation) SetCollectNum(i int) {
	m.collect_num = &i
	m.addcollect_num = nil
}

// CollectNum returns the value of the "collect_num" field in the mutation.
func (m *BlogsMutation) CollectNum() (r int, exists bool) {
	v := m.collect_num
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectNum returns the old "collect_num" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCollectNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectNum: %w", err)
	}
	return oldValue.CollectNum, nil
}

// AddCollectNum adds i to the "collect_num" field.
func (m *BlogsMutation) AddCollectNum(i int) {
	if m.addcollect_num != nil {
		*m.addcollect_num += i
	} else {
		m.addcollect_num = &i
	}
}

// AddedCollectNum returns the value that was added to the "collect_num" field in this mutation.
func (m *BlogsMutation) AddedCollectNum() (r int, exists bool) {
	v := m.addcollect_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectNum resets all changes to the "collect_num" field.
func (m *BlogsMutation) ResetCollectNum() {
	m.collect_num = nil
	m.addcollect_num = nil
}

// SetLoveNum sets the "love_num" field.
func (m *BlogsMutation) SetLoveNum(i int) {
	m.love_num = &i
	m.addlove_num = nil
}

// LoveNum returns the value of the "love_num" field in the mutation.
func (m *BlogsMutation) LoveNum() (r int, exists bool) {
	v := m.love_num
	if v == nil {
		return
	}
	return *v, true
}

// OldLoveNum returns the old "love_num" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldLoveNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoveNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoveNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoveNum: %w", err)
	}
	return oldValue.LoveNum, nil
}

// AddLoveNum adds i to the "love_num" field.
func (m *BlogsMutation) AddLoveNum(i int) {
	if m.addlove_num != nil {
		*m.addlove_num += i
	} else {
		m.addlove_num = &i
	}
}

// AddedLoveNum returns the value that was added to the "love_num" field in this mutation.
func (m *BlogsMutation) AddedLoveNum() (r int, exists bool) {
	v := m.addlove_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoveNum resets all changes to the "love_num" field.
func (m *BlogsMutation) ResetLoveNum() {
	m.love_num = nil
	m.addlove_num = nil
}

// AddTagIDs adds the "tag" edge to the Tags entity by ids.
func (m *BlogsMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tags entity.
func (m *BlogsMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tags entity was cleared.
func (m *BlogsMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tags entity by IDs.
func (m *BlogsMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tags entity.
func (m *BlogsMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *BlogsMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *BlogsMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddTagRelationIDs adds the "tag_relation" edge to the TagsRelation entity by ids.
func (m *BlogsMutation) AddTagRelationIDs(ids ...int) {
	if m.tag_relation == nil {
		m.tag_relation = make(map[int]struct{})
	}
	for i := range ids {
		m.tag_relation[ids[i]] = struct{}{}
	}
}

// ClearTagRelation clears the "tag_relation" edge to the TagsRelation entity.
func (m *BlogsMutation) ClearTagRelation() {
	m.clearedtag_relation = true
}

// TagRelationCleared reports if the "tag_relation" edge to the TagsRelation entity was cleared.
func (m *BlogsMutation) TagRelationCleared() bool {
	return m.clearedtag_relation
}

// RemoveTagRelationIDs removes the "tag_relation" edge to the TagsRelation entity by IDs.
func (m *BlogsMutation) RemoveTagRelationIDs(ids ...int) {
	if m.removedtag_relation == nil {
		m.removedtag_relation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag_relation, ids[i])
		m.removedtag_relation[ids[i]] = struct{}{}
	}
}

// RemovedTagRelation returns the removed IDs of the "tag_relation" edge to the TagsRelation entity.
func (m *BlogsMutation) RemovedTagRelationIDs() (ids []int) {
	for id := range m.removedtag_relation {
		ids = append(ids, id)
	}
	return
}

// TagRelationIDs returns the "tag_relation" edge IDs in the mutation.
func (m *BlogsMutation) TagRelationIDs() (ids []int) {
	for id := range m.tag_relation {
		ids = append(ids, id)
	}
	return
}

// ResetTagRelation resets all changes to the "tag_relation" edge.
func (m *BlogsMutation) ResetTagRelation() {
	m.tag_relation = nil
	m.clearedtag_relation = false
	m.removedtag_relation = nil
}

// Where appends a list predicates to the BlogsMutation builder.
func (m *BlogsMutation) Where(ps ...predicate.Blogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blogs).
func (m *BlogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.title != nil {
		fields = append(fields, blogs.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blogs.FieldDescription)
	}
	if m.is_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	if m.tags != nil {
		fields = append(fields, blogs.FieldTags)
	}
	if m.cover != nil {
		fields = append(fields, blogs.FieldCover)
	}
	if m.browse_num != nil {
		fields = append(fields, blogs.FieldBrowseNum)
	}
	if m.collect_num != nil {
		fields = append(fields, blogs.FieldCollectNum)
	}
	if m.love_num != nil {
		fields = append(fields, blogs.FieldLoveNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.CreatedAt()
	case blogs.FieldCreatedBy:
		return m.CreatedBy()
	case blogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogs.FieldDeletedAt:
		return m.DeletedAt()
	case blogs.FieldDeletedBy:
		return m.DeletedBy()
	case blogs.FieldAccountID:
		return m.AccountID()
	case blogs.FieldTitle:
		return m.Title()
	case blogs.FieldDescription:
		return m.Description()
	case blogs.FieldIsHidden:
		return m.IsHidden()
	case blogs.FieldTags:
		return m.Tags()
	case blogs.FieldCover:
		return m.Cover()
	case blogs.FieldBrowseNum:
		return m.BrowseNum()
	case blogs.FieldCollectNum:
		return m.CollectNum()
	case blogs.FieldLoveNum:
		return m.LoveNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogs.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogs.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogs.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogs.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogs.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogs.FieldTitle:
		return m.OldTitle(ctx)
	case blogs.FieldDescription:
		return m.OldDescription(ctx)
	case blogs.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case blogs.FieldTags:
		return m.OldTags(ctx)
	case blogs.FieldCover:
		return m.OldCover(ctx)
	case blogs.FieldBrowseNum:
		return m.OldBrowseNum(ctx)
	case blogs.FieldCollectNum:
		return m.OldCollectNum(ctx)
	case blogs.FieldLoveNum:
		return m.OldLoveNum(ctx)
	}
	return nil, fmt.Errorf("unknown Blogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogs.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogs.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case blogs.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case blogs.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case blogs.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseNum(v)
		return nil
	case blogs.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectNum(v)
		return nil
	case blogs.FieldLoveNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoveNum(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.addis_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	if m.addbrowse_num != nil {
		fields = append(fields, blogs.FieldBrowseNum)
	}
	if m.addcollect_num != nil {
		fields = append(fields, blogs.FieldCollectNum)
	}
	if m.addlove_num != nil {
		fields = append(fields, blogs.FieldLoveNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogs.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogs.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogs.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogs.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogs.FieldAccountID:
		return m.AddedAccountID()
	case blogs.FieldIsHidden:
		return m.AddedIsHidden()
	case blogs.FieldBrowseNum:
		return m.AddedBrowseNum()
	case blogs.FieldCollectNum:
		return m.AddedCollectNum()
	case blogs.FieldLoveNum:
		return m.AddedLoveNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHidden(v)
		return nil
	case blogs.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseNum(v)
		return nil
	case blogs.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectNum(v)
		return nil
	case blogs.FieldLoveNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoveNum(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsMutation) ResetField(name string) error {
	switch name {
	case blogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogs.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogs.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogs.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogs.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogs.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogs.FieldTitle:
		m.ResetTitle()
		return nil
	case blogs.FieldDescription:
		m.ResetDescription()
		return nil
	case blogs.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case blogs.FieldTags:
		m.ResetTags()
		return nil
	case blogs.FieldCover:
		m.ResetCover()
		return nil
	case blogs.FieldBrowseNum:
		m.ResetBrowseNum()
		return nil
	case blogs.FieldCollectNum:
		m.ResetCollectNum()
		return nil
	case blogs.FieldLoveNum:
		m.ResetLoveNum()
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, blogs.EdgeTag)
	}
	if m.tag_relation != nil {
		edges = append(edges, blogs.EdgeTagRelation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogs.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case blogs.EdgeTagRelation:
		ids := make([]ent.Value, 0, len(m.tag_relation))
		for id := range m.tag_relation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtag != nil {
		edges = append(edges, blogs.EdgeTag)
	}
	if m.removedtag_relation != nil {
		edges = append(edges, blogs.EdgeTagRelation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogs.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case blogs.EdgeTagRelation:
		ids := make([]ent.Value, 0, len(m.removedtag_relation))
		for id := range m.removedtag_relation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, blogs.EdgeTag)
	}
	if m.clearedtag_relation {
		edges = append(edges, blogs.EdgeTagRelation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsMutation) EdgeCleared(name string) bool {
	switch name {
	case blogs.EdgeTag:
		return m.clearedtag
	case blogs.EdgeTagRelation:
		return m.clearedtag_relation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsMutation) ResetEdge(name string) error {
	switch name {
	case blogs.EdgeTag:
		m.ResetTag()
		return nil
	case blogs.EdgeTagRelation:
		m.ResetTagRelation()
		return nil
	}
	return fmt.Errorf("unknown Blogs edge %s", name)
}

// BlogsCommentMutation represents an operation that mutates the BlogsComment nodes in the graph.
type BlogsCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	blog_id       *int
	addblog_id    *int
	top_id        *int
	addtop_id     *int
	parent_id     *int
	addparent_id  *int
	level         *int
	addlevel      *int
	total         *int
	addtotal      *int
	status        *int8
	addstatus     *int8
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsComment, error)
	predicates    []predicate.BlogsComment
}

var _ ent.Mutation = (*BlogsCommentMutation)(nil)

// blogscommentOption allows management of the mutation configuration using functional options.
type blogscommentOption func(*BlogsCommentMutation)

// newBlogsCommentMutation creates new mutation for the BlogsComment entity.
func newBlogsCommentMutation(c config, op Op, opts ...blogscommentOption) *BlogsCommentMutation {
	m := &BlogsCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsCommentID sets the ID field of the mutation.
func withBlogsCommentID(id int) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsComment
		)
		m.oldValue = func(ctx context.Context) (*BlogsComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsComment sets the old BlogsComment of the mutation.
func withBlogsComment(node *BlogsComment) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		m.oldValue = func(context.Context) (*BlogsComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsComment entities.
func (m *BlogsCommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsCommentMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsCommentMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsCommentMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsCommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsCommentMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsCommentMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsCommentMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsCommentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsCommentMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsCommentMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsCommentMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsCommentMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsCommentMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsCommentMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsCommentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsCommentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsCommentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsCommentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsCommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsCommentMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsCommentMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsCommentMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsCommentMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsCommentMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsCommentMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsCommentMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsCommentMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsCommentMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetBlogID sets the "blog_id" field.
func (m *BlogsCommentMutation) SetBlogID(i int) {
	m.blog_id = &i
	m.addblog_id = nil
}

// BlogID returns the value of the "blog_id" field in the mutation.
func (m *BlogsCommentMutation) BlogID() (r int, exists bool) {
	v := m.blog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogID returns the old "blog_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldBlogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogID: %w", err)
	}
	return oldValue.BlogID, nil
}

// AddBlogID adds i to the "blog_id" field.
func (m *BlogsCommentMutation) AddBlogID(i int) {
	if m.addblog_id != nil {
		*m.addblog_id += i
	} else {
		m.addblog_id = &i
	}
}

// AddedBlogID returns the value that was added to the "blog_id" field in this mutation.
func (m *BlogsCommentMutation) AddedBlogID() (r int, exists bool) {
	v := m.addblog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogID resets all changes to the "blog_id" field.
func (m *BlogsCommentMutation) ResetBlogID() {
	m.blog_id = nil
	m.addblog_id = nil
}

// SetTopID sets the "top_id" field.
func (m *BlogsCommentMutation) SetTopID(i int) {
	m.top_id = &i
	m.addtop_id = nil
}

// TopID returns the value of the "top_id" field in the mutation.
func (m *BlogsCommentMutation) TopID() (r int, exists bool) {
	v := m.top_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopID returns the old "top_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopID: %w", err)
	}
	return oldValue.TopID, nil
}

// AddTopID adds i to the "top_id" field.
func (m *BlogsCommentMutation) AddTopID(i int) {
	if m.addtop_id != nil {
		*m.addtop_id += i
	} else {
		m.addtop_id = &i
	}
}

// AddedTopID returns the value that was added to the "top_id" field in this mutation.
func (m *BlogsCommentMutation) AddedTopID() (r int, exists bool) {
	v := m.addtop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopID resets all changes to the "top_id" field.
func (m *BlogsCommentMutation) ResetTopID() {
	m.top_id = nil
	m.addtop_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *BlogsCommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BlogsCommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *BlogsCommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *BlogsCommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BlogsCommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetLevel sets the "level" field.
func (m *BlogsCommentMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *BlogsCommentMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *BlogsCommentMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *BlogsCommentMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *BlogsCommentMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetTotal sets the "total" field.
func (m *BlogsCommentMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *BlogsCommentMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *BlogsCommentMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *BlogsCommentMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *BlogsCommentMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetStatus sets the "status" field.
func (m *BlogsCommentMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogsCommentMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BlogsCommentMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BlogsCommentMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogsCommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetContent sets the "content" field.
func (m *BlogsCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsCommentMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the BlogsCommentMutation builder.
func (m *BlogsCommentMutation) Where(ps ...predicate.BlogsComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsComment).
func (m *BlogsCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsCommentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.blog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.top_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.parent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.level != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.total != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.status != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, blogscomment.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.CreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.CreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.DeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.DeletedBy()
	case blogscomment.FieldAccountID:
		return m.AccountID()
	case blogscomment.FieldBlogID:
		return m.BlogID()
	case blogscomment.FieldTopID:
		return m.TopID()
	case blogscomment.FieldParentID:
		return m.ParentID()
	case blogscomment.FieldLevel:
		return m.Level()
	case blogscomment.FieldTotal:
		return m.Total()
	case blogscomment.FieldStatus:
		return m.Status()
	case blogscomment.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogscomment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogscomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogscomment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogscomment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogscomment.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogscomment.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogscomment.FieldBlogID:
		return m.OldBlogID(ctx)
	case blogscomment.FieldTopID:
		return m.OldTopID(ctx)
	case blogscomment.FieldParentID:
		return m.OldParentID(ctx)
	case blogscomment.FieldLevel:
		return m.OldLevel(ctx)
	case blogscomment.FieldTotal:
		return m.OldTotal(ctx)
	case blogscomment.FieldStatus:
		return m.OldStatus(ctx)
	case blogscomment.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogscomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsCommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.addblog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.addtop_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.addparent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.addlevel != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.addtotal != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.addstatus != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogscomment.FieldAccountID:
		return m.AddedAccountID()
	case blogscomment.FieldBlogID:
		return m.AddedBlogID()
	case blogscomment.FieldTopID:
		return m.AddedTopID()
	case blogscomment.FieldParentID:
		return m.AddedParentID()
	case blogscomment.FieldLevel:
		return m.AddedLevel()
	case blogscomment.FieldTotal:
		return m.AddedTotal()
	case blogscomment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ResetField(name string) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogscomment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogscomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogscomment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogscomment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogscomment.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogscomment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogscomment.FieldBlogID:
		m.ResetBlogID()
		return nil
	case blogscomment.FieldTopID:
		m.ResetTopID()
		return nil
	case blogscomment.FieldParentID:
		m.ResetParentID()
		return nil
	case blogscomment.FieldLevel:
		m.ResetLevel()
		return nil
	case blogscomment.FieldTotal:
		m.ResetTotal()
		return nil
	case blogscomment.FieldStatus:
		m.ResetStatus()
		return nil
	case blogscomment.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsCommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsCommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsCommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsCommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment edge %s", name)
}

// BlogsContentMutation represents an operation that mutates the BlogsContent nodes in the graph.
type BlogsContentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	files         *[]string
	appendfiles   []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsContent, error)
	predicates    []predicate.BlogsContent
}

var _ ent.Mutation = (*BlogsContentMutation)(nil)

// blogscontentOption allows management of the mutation configuration using functional options.
type blogscontentOption func(*BlogsContentMutation)

// newBlogsContentMutation creates new mutation for the BlogsContent entity.
func newBlogsContentMutation(c config, op Op, opts ...blogscontentOption) *BlogsContentMutation {
	m := &BlogsContentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsContentID sets the ID field of the mutation.
func withBlogsContentID(id int) blogscontentOption {
	return func(m *BlogsContentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsContent
		)
		m.oldValue = func(ctx context.Context) (*BlogsContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsContent sets the old BlogsContent of the mutation.
func withBlogsContent(node *BlogsContent) blogscontentOption {
	return func(m *BlogsContentMutation) {
		m.oldValue = func(context.Context) (*BlogsContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsContent entities.
func (m *BlogsContentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsContentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsContentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *BlogsContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsContent entity.
// If the BlogsContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsContentMutation) ResetContent() {
	m.content = nil
}

// SetFiles sets the "files" field.
func (m *BlogsContentMutation) SetFiles(s []string) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *BlogsContentMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the BlogsContent entity.
// If the BlogsContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsContentMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *BlogsContentMutation) AppendFiles(s []string) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *BlogsContentMutation) AppendedFiles() ([]string, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ResetFiles resets all changes to the "files" field.
func (m *BlogsContentMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
}

// Where appends a list predicates to the BlogsContentMutation builder.
func (m *BlogsContentMutation) Where(ps ...predicate.BlogsContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsContent).
func (m *BlogsContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsContentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.content != nil {
		fields = append(fields, blogscontent.FieldContent)
	}
	if m.files != nil {
		fields = append(fields, blogscontent.FieldFiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscontent.FieldContent:
		return m.Content()
	case blogscontent.FieldFiles:
		return m.Files()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscontent.FieldContent:
		return m.OldContent(ctx)
	case blogscontent.FieldFiles:
		return m.OldFiles(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogscontent.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogsContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsContentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsContentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsContentMutation) ResetField(name string) error {
	switch name {
	case blogscontent.FieldContent:
		m.ResetContent()
		return nil
	case blogscontent.FieldFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsContentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsContentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsContentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsContentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent edge %s", name)
}

// BlogsExtendMutation represents an operation that mutates the BlogsExtend nodes in the graph.
type BlogsExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	blog_id       *int
	addblog_id    *int
	account_id    *int
	addaccount_id *int
	browse_num    *int
	addbrowse_num *int
	browse_at     *int64
	addbrowse_at  *int64
	collect       *bool
	collect_at    *int64
	addcollect_at *int64
	love          *bool
	love_at       *int64
	addlove_at    *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsExtend, error)
	predicates    []predicate.BlogsExtend
}

var _ ent.Mutation = (*BlogsExtendMutation)(nil)

// blogsextendOption allows management of the mutation configuration using functional options.
type blogsextendOption func(*BlogsExtendMutation)

// newBlogsExtendMutation creates new mutation for the BlogsExtend entity.
func newBlogsExtendMutation(c config, op Op, opts ...blogsextendOption) *BlogsExtendMutation {
	m := &BlogsExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsExtendID sets the ID field of the mutation.
func withBlogsExtendID(id int) blogsextendOption {
	return func(m *BlogsExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsExtend
		)
		m.oldValue = func(ctx context.Context) (*BlogsExtend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsExtend sets the old BlogsExtend of the mutation.
func withBlogsExtend(node *BlogsExtend) blogsextendOption {
	return func(m *BlogsExtendMutation) {
		m.oldValue = func(context.Context) (*BlogsExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsExtend entities.
func (m *BlogsExtendMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsExtendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsExtendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsExtend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogID sets the "blog_id" field.
func (m *BlogsExtendMutation) SetBlogID(i int) {
	m.blog_id = &i
	m.addblog_id = nil
}

// BlogID returns the value of the "blog_id" field in the mutation.
func (m *BlogsExtendMutation) BlogID() (r int, exists bool) {
	v := m.blog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogID returns the old "blog_id" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldBlogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogID: %w", err)
	}
	return oldValue.BlogID, nil
}

// AddBlogID adds i to the "blog_id" field.
func (m *BlogsExtendMutation) AddBlogID(i int) {
	if m.addblog_id != nil {
		*m.addblog_id += i
	} else {
		m.addblog_id = &i
	}
}

// AddedBlogID returns the value that was added to the "blog_id" field in this mutation.
func (m *BlogsExtendMutation) AddedBlogID() (r int, exists bool) {
	v := m.addblog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogID resets all changes to the "blog_id" field.
func (m *BlogsExtendMutation) ResetBlogID() {
	m.blog_id = nil
	m.addblog_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsExtendMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsExtendMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsExtendMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsExtendMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsExtendMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetBrowseNum sets the "browse_num" field.
func (m *BlogsExtendMutation) SetBrowseNum(i int) {
	m.browse_num = &i
	m.addbrowse_num = nil
}

// BrowseNum returns the value of the "browse_num" field in the mutation.
func (m *BlogsExtendMutation) BrowseNum() (r int, exists bool) {
	v := m.browse_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseNum returns the old "browse_num" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldBrowseNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseNum: %w", err)
	}
	return oldValue.BrowseNum, nil
}

// AddBrowseNum adds i to the "browse_num" field.
func (m *BlogsExtendMutation) AddBrowseNum(i int) {
	if m.addbrowse_num != nil {
		*m.addbrowse_num += i
	} else {
		m.addbrowse_num = &i
	}
}

// AddedBrowseNum returns the value that was added to the "browse_num" field in this mutation.
func (m *BlogsExtendMutation) AddedBrowseNum() (r int, exists bool) {
	v := m.addbrowse_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseNum resets all changes to the "browse_num" field.
func (m *BlogsExtendMutation) ResetBrowseNum() {
	m.browse_num = nil
	m.addbrowse_num = nil
}

// SetBrowseAt sets the "browse_at" field.
func (m *BlogsExtendMutation) SetBrowseAt(i int64) {
	m.browse_at = &i
	m.addbrowse_at = nil
}

// BrowseAt returns the value of the "browse_at" field in the mutation.
func (m *BlogsExtendMutation) BrowseAt() (r int64, exists bool) {
	v := m.browse_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseAt returns the old "browse_at" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldBrowseAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseAt: %w", err)
	}
	return oldValue.BrowseAt, nil
}

// AddBrowseAt adds i to the "browse_at" field.
func (m *BlogsExtendMutation) AddBrowseAt(i int64) {
	if m.addbrowse_at != nil {
		*m.addbrowse_at += i
	} else {
		m.addbrowse_at = &i
	}
}

// AddedBrowseAt returns the value that was added to the "browse_at" field in this mutation.
func (m *BlogsExtendMutation) AddedBrowseAt() (r int64, exists bool) {
	v := m.addbrowse_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseAt resets all changes to the "browse_at" field.
func (m *BlogsExtendMutation) ResetBrowseAt() {
	m.browse_at = nil
	m.addbrowse_at = nil
}

// SetCollect sets the "collect" field.
func (m *BlogsExtendMutation) SetCollect(b bool) {
	m.collect = &b
}

// Collect returns the value of the "collect" field in the mutation.
func (m *BlogsExtendMutation) Collect() (r bool, exists bool) {
	v := m.collect
	if v == nil {
		return
	}
	return *v, true
}

// OldCollect returns the old "collect" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollect: %w", err)
	}
	return oldValue.Collect, nil
}

// ResetCollect resets all changes to the "collect" field.
func (m *BlogsExtendMutation) ResetCollect() {
	m.collect = nil
}

// SetCollectAt sets the "collect_at" field.
func (m *BlogsExtendMutation) SetCollectAt(i int64) {
	m.collect_at = &i
	m.addcollect_at = nil
}

// CollectAt returns the value of the "collect_at" field in the mutation.
func (m *BlogsExtendMutation) CollectAt() (r int64, exists bool) {
	v := m.collect_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectAt returns the old "collect_at" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldCollectAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectAt: %w", err)
	}
	return oldValue.CollectAt, nil
}

// AddCollectAt adds i to the "collect_at" field.
func (m *BlogsExtendMutation) AddCollectAt(i int64) {
	if m.addcollect_at != nil {
		*m.addcollect_at += i
	} else {
		m.addcollect_at = &i
	}
}

// AddedCollectAt returns the value that was added to the "collect_at" field in this mutation.
func (m *BlogsExtendMutation) AddedCollectAt() (r int64, exists bool) {
	v := m.addcollect_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectAt resets all changes to the "collect_at" field.
func (m *BlogsExtendMutation) ResetCollectAt() {
	m.collect_at = nil
	m.addcollect_at = nil
}

// SetLove sets the "love" field.
func (m *BlogsExtendMutation) SetLove(b bool) {
	m.love = &b
}

// Love returns the value of the "love" field in the mutation.
func (m *BlogsExtendMutation) Love() (r bool, exists bool) {
	v := m.love
	if v == nil {
		return
	}
	return *v, true
}

// OldLove returns the old "love" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldLove(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLove is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLove requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLove: %w", err)
	}
	return oldValue.Love, nil
}

// ResetLove resets all changes to the "love" field.
func (m *BlogsExtendMutation) ResetLove() {
	m.love = nil
}

// SetLoveAt sets the "love_at" field.
func (m *BlogsExtendMutation) SetLoveAt(i int64) {
	m.love_at = &i
	m.addlove_at = nil
}

// LoveAt returns the value of the "love_at" field in the mutation.
func (m *BlogsExtendMutation) LoveAt() (r int64, exists bool) {
	v := m.love_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLoveAt returns the old "love_at" field's value of the BlogsExtend entity.
// If the BlogsExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsExtendMutation) OldLoveAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoveAt: %w", err)
	}
	return oldValue.LoveAt, nil
}

// AddLoveAt adds i to the "love_at" field.
func (m *BlogsExtendMutation) AddLoveAt(i int64) {
	if m.addlove_at != nil {
		*m.addlove_at += i
	} else {
		m.addlove_at = &i
	}
}

// AddedLoveAt returns the value that was added to the "love_at" field in this mutation.
func (m *BlogsExtendMutation) AddedLoveAt() (r int64, exists bool) {
	v := m.addlove_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoveAt resets all changes to the "love_at" field.
func (m *BlogsExtendMutation) ResetLoveAt() {
	m.love_at = nil
	m.addlove_at = nil
}

// Where appends a list predicates to the BlogsExtendMutation builder.
func (m *BlogsExtendMutation) Where(ps ...predicate.BlogsExtend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsExtendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsExtendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsExtend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsExtendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsExtendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsExtend).
func (m *BlogsExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsExtendMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.blog_id != nil {
		fields = append(fields, blogsextend.FieldBlogID)
	}
	if m.account_id != nil {
		fields = append(fields, blogsextend.FieldAccountID)
	}
	if m.browse_num != nil {
		fields = append(fields, blogsextend.FieldBrowseNum)
	}
	if m.browse_at != nil {
		fields = append(fields, blogsextend.FieldBrowseAt)
	}
	if m.collect != nil {
		fields = append(fields, blogsextend.FieldCollect)
	}
	if m.collect_at != nil {
		fields = append(fields, blogsextend.FieldCollectAt)
	}
	if m.love != nil {
		fields = append(fields, blogsextend.FieldLove)
	}
	if m.love_at != nil {
		fields = append(fields, blogsextend.FieldLoveAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogsextend.FieldBlogID:
		return m.BlogID()
	case blogsextend.FieldAccountID:
		return m.AccountID()
	case blogsextend.FieldBrowseNum:
		return m.BrowseNum()
	case blogsextend.FieldBrowseAt:
		return m.BrowseAt()
	case blogsextend.FieldCollect:
		return m.Collect()
	case blogsextend.FieldCollectAt:
		return m.CollectAt()
	case blogsextend.FieldLove:
		return m.Love()
	case blogsextend.FieldLoveAt:
		return m.LoveAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogsextend.FieldBlogID:
		return m.OldBlogID(ctx)
	case blogsextend.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogsextend.FieldBrowseNum:
		return m.OldBrowseNum(ctx)
	case blogsextend.FieldBrowseAt:
		return m.OldBrowseAt(ctx)
	case blogsextend.FieldCollect:
		return m.OldCollect(ctx)
	case blogsextend.FieldCollectAt:
		return m.OldCollectAt(ctx)
	case blogsextend.FieldLove:
		return m.OldLove(ctx)
	case blogsextend.FieldLoveAt:
		return m.OldLoveAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsExtend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogsextend.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogID(v)
		return nil
	case blogsextend.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogsextend.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseNum(v)
		return nil
	case blogsextend.FieldBrowseAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseAt(v)
		return nil
	case blogsextend.FieldCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollect(v)
		return nil
	case blogsextend.FieldCollectAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectAt(v)
		return nil
	case blogsextend.FieldLove:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLove(v)
		return nil
	case blogsextend.FieldLoveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoveAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsExtendMutation) AddedFields() []string {
	var fields []string
	if m.addblog_id != nil {
		fields = append(fields, blogsextend.FieldBlogID)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogsextend.FieldAccountID)
	}
	if m.addbrowse_num != nil {
		fields = append(fields, blogsextend.FieldBrowseNum)
	}
	if m.addbrowse_at != nil {
		fields = append(fields, blogsextend.FieldBrowseAt)
	}
	if m.addcollect_at != nil {
		fields = append(fields, blogsextend.FieldCollectAt)
	}
	if m.addlove_at != nil {
		fields = append(fields, blogsextend.FieldLoveAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsExtendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogsextend.FieldBlogID:
		return m.AddedBlogID()
	case blogsextend.FieldAccountID:
		return m.AddedAccountID()
	case blogsextend.FieldBrowseNum:
		return m.AddedBrowseNum()
	case blogsextend.FieldBrowseAt:
		return m.AddedBrowseAt()
	case blogsextend.FieldCollectAt:
		return m.AddedCollectAt()
	case blogsextend.FieldLoveAt:
		return m.AddedLoveAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogsextend.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogID(v)
		return nil
	case blogsextend.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogsextend.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseNum(v)
		return nil
	case blogsextend.FieldBrowseAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseAt(v)
		return nil
	case blogsextend.FieldCollectAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectAt(v)
		return nil
	case blogsextend.FieldLoveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoveAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsExtendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsExtendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsExtendMutation) ResetField(name string) error {
	switch name {
	case blogsextend.FieldBlogID:
		m.ResetBlogID()
		return nil
	case blogsextend.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogsextend.FieldBrowseNum:
		m.ResetBrowseNum()
		return nil
	case blogsextend.FieldBrowseAt:
		m.ResetBrowseAt()
		return nil
	case blogsextend.FieldCollect:
		m.ResetCollect()
		return nil
	case blogsextend.FieldCollectAt:
		m.ResetCollectAt()
		return nil
	case blogsextend.FieldLove:
		m.ResetLove()
		return nil
	case blogsextend.FieldLoveAt:
		m.ResetLoveAt()
		return nil
	}
	return fmt.Errorf("unknown BlogsExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsExtendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsExtendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsExtendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsExtend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsExtendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsExtend edge %s", name)
}

// FilesMutation represents an operation that mutates the Files nodes in the graph.
type FilesMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	_type          *string
	size           *int64
	addsize        *int64
	name           *string
	_path          *string
	clearedFields  map[string]struct{}
	extends        map[int]struct{}
	removedextends map[int]struct{}
	clearedextends bool
	done           bool
	oldValue       func(context.Context) (*Files, error)
	predicates     []predicate.Files
}

var _ ent.Mutation = (*FilesMutation)(nil)

// filesOption allows management of the mutation configuration using functional options.
type filesOption func(*FilesMutation)

// newFilesMutation creates new mutation for the Files entity.
func newFilesMutation(c config, op Op, opts ...filesOption) *FilesMutation {
	m := &FilesMutation{
		config:        c,
		op:            op,
		typ:           TypeFiles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesID sets the ID field of the mutation.
func withFilesID(id string) filesOption {
	return func(m *FilesMutation) {
		var (
			err   error
			once  sync.Once
			value *Files
		)
		m.oldValue = func(ctx context.Context) (*Files, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Files.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFiles sets the old Files of the mutation.
func withFiles(node *Files) filesOption {
	return func(m *FilesMutation) {
		m.oldValue = func(context.Context) (*Files, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Files entities.
func (m *FilesMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Files.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetType sets the "type" field.
func (m *FilesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FilesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FilesMutation) ResetType() {
	m._type = nil
}

// SetSize sets the "size" field.
func (m *FilesMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FilesMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FilesMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FilesMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FilesMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetName sets the "name" field.
func (m *FilesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FilesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FilesMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FilesMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FilesMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FilesMutation) ResetPath() {
	m._path = nil
}

// AddExtendIDs adds the "extends" edge to the FilesExtend entity by ids.
func (m *FilesMutation) AddExtendIDs(ids ...int) {
	if m.extends == nil {
		m.extends = make(map[int]struct{})
	}
	for i := range ids {
		m.extends[ids[i]] = struct{}{}
	}
}

// ClearExtends clears the "extends" edge to the FilesExtend entity.
func (m *FilesMutation) ClearExtends() {
	m.clearedextends = true
}

// ExtendsCleared reports if the "extends" edge to the FilesExtend entity was cleared.
func (m *FilesMutation) ExtendsCleared() bool {
	return m.clearedextends
}

// RemoveExtendIDs removes the "extends" edge to the FilesExtend entity by IDs.
func (m *FilesMutation) RemoveExtendIDs(ids ...int) {
	if m.removedextends == nil {
		m.removedextends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extends, ids[i])
		m.removedextends[ids[i]] = struct{}{}
	}
}

// RemovedExtends returns the removed IDs of the "extends" edge to the FilesExtend entity.
func (m *FilesMutation) RemovedExtendsIDs() (ids []int) {
	for id := range m.removedextends {
		ids = append(ids, id)
	}
	return
}

// ExtendsIDs returns the "extends" edge IDs in the mutation.
func (m *FilesMutation) ExtendsIDs() (ids []int) {
	for id := range m.extends {
		ids = append(ids, id)
	}
	return
}

// ResetExtends resets all changes to the "extends" edge.
func (m *FilesMutation) ResetExtends() {
	m.extends = nil
	m.clearedextends = false
	m.removedextends = nil
}

// Where appends a list predicates to the FilesMutation builder.
func (m *FilesMutation) Where(ps ...predicate.Files) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Files, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Files).
func (m *FilesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m._type != nil {
		fields = append(fields, files.FieldType)
	}
	if m.size != nil {
		fields = append(fields, files.FieldSize)
	}
	if m.name != nil {
		fields = append(fields, files.FieldName)
	}
	if m._path != nil {
		fields = append(fields, files.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.CreatedAt()
	case files.FieldCreatedBy:
		return m.CreatedBy()
	case files.FieldUpdatedAt:
		return m.UpdatedAt()
	case files.FieldUpdatedBy:
		return m.UpdatedBy()
	case files.FieldDeletedAt:
		return m.DeletedAt()
	case files.FieldDeletedBy:
		return m.DeletedBy()
	case files.FieldType:
		return m.GetType()
	case files.FieldSize:
		return m.Size()
	case files.FieldName:
		return m.Name()
	case files.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case files.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case files.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case files.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case files.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case files.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case files.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case files.FieldType:
		return m.OldType(ctx)
	case files.FieldSize:
		return m.OldSize(ctx)
	case files.FieldName:
		return m.OldName(ctx)
	case files.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Files field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case files.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case files.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case files.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m.addsize != nil {
		fields = append(fields, files.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.AddedCreatedAt()
	case files.FieldCreatedBy:
		return m.AddedCreatedBy()
	case files.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case files.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case files.FieldDeletedAt:
		return m.AddedDeletedAt()
	case files.FieldDeletedBy:
		return m.AddedDeletedBy()
	case files.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Files numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Files nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesMutation) ResetField(name string) error {
	switch name {
	case files.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case files.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case files.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case files.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case files.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case files.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case files.FieldType:
		m.ResetType()
		return nil
	case files.FieldSize:
		m.ResetSize()
		return nil
	case files.FieldName:
		m.ResetName()
		return nil
	case files.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extends != nil {
		edges = append(edges, files.EdgeExtends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case files.EdgeExtends:
		ids := make([]ent.Value, 0, len(m.extends))
		for id := range m.extends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedextends != nil {
		edges = append(edges, files.EdgeExtends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case files.EdgeExtends:
		ids := make([]ent.Value, 0, len(m.removedextends))
		for id := range m.removedextends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextends {
		edges = append(edges, files.EdgeExtends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesMutation) EdgeCleared(name string) bool {
	switch name {
	case files.EdgeExtends:
		return m.clearedextends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Files unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesMutation) ResetEdge(name string) error {
	switch name {
	case files.EdgeExtends:
		m.ResetExtends()
		return nil
	}
	return fmt.Errorf("unknown Files edge %s", name)
}

// FilesExtendMutation represents an operation that mutates the FilesExtend nodes in the graph.
type FilesExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	user_id       *int
	adduser_id    *int
	from          *string
	from_id       *int
	addfrom_id    *int
	is_hidden     *bool
	clearedFields map[string]struct{}
	files         *string
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*FilesExtend, error)
	predicates    []predicate.FilesExtend
}

var _ ent.Mutation = (*FilesExtendMutation)(nil)

// filesextendOption allows management of the mutation configuration using functional options.
type filesextendOption func(*FilesExtendMutation)

// newFilesExtendMutation creates new mutation for the FilesExtend entity.
func newFilesExtendMutation(c config, op Op, opts ...filesextendOption) *FilesExtendMutation {
	m := &FilesExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeFilesExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesExtendID sets the ID field of the mutation.
func withFilesExtendID(id int) filesextendOption {
	return func(m *FilesExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *FilesExtend
		)
		m.oldValue = func(ctx context.Context) (*FilesExtend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilesExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilesExtend sets the old FilesExtend of the mutation.
func withFilesExtend(node *FilesExtend) filesextendOption {
	return func(m *FilesExtendMutation) {
		m.oldValue = func(context.Context) (*FilesExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FilesExtend entities.
func (m *FilesExtendMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesExtendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesExtendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilesExtend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesExtendMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesExtendMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesExtendMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesExtendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesExtendMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesExtendMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesExtendMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesExtendMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesExtendMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesExtendMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesExtendMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesExtendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesExtendMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesExtendMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesExtendMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesExtendMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesExtendMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesExtendMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesExtendMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesExtendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesExtendMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesExtendMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesExtendMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesExtendMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetFileID sets the "file_id" field.
func (m *FilesExtendMutation) SetFileID(s string) {
	m.files = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FilesExtendMutation) FileID() (r string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *FilesExtendMutation) ClearFileID() {
	m.files = nil
	m.clearedFields[filesextend.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *FilesExtendMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[filesextend.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FilesExtendMutation) ResetFileID() {
	m.files = nil
	delete(m.clearedFields, filesextend.FieldFileID)
}

// SetUserID sets the "user_id" field.
func (m *FilesExtendMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FilesExtendMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FilesExtendMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FilesExtendMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FilesExtendMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetFrom sets the "from" field.
func (m *FilesExtendMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *FilesExtendMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *FilesExtendMutation) ResetFrom() {
	m.from = nil
}

// SetFromID sets the "from_id" field.
func (m *FilesExtendMutation) SetFromID(i int) {
	m.from_id = &i
	m.addfrom_id = nil
}

// FromID returns the value of the "from_id" field in the mutation.
func (m *FilesExtendMutation) FromID() (r int, exists bool) {
	v := m.from_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromID returns the old "from_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFromID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromID: %w", err)
	}
	return oldValue.FromID, nil
}

// AddFromID adds i to the "from_id" field.
func (m *FilesExtendMutation) AddFromID(i int) {
	if m.addfrom_id != nil {
		*m.addfrom_id += i
	} else {
		m.addfrom_id = &i
	}
}

// AddedFromID returns the value that was added to the "from_id" field in this mutation.
func (m *FilesExtendMutation) AddedFromID() (r int, exists bool) {
	v := m.addfrom_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromID resets all changes to the "from_id" field.
func (m *FilesExtendMutation) ResetFromID() {
	m.from_id = nil
	m.addfrom_id = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *FilesExtendMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *FilesExtendMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *FilesExtendMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetFilesID sets the "files" edge to the Files entity by id.
func (m *FilesExtendMutation) SetFilesID(id string) {
	m.files = &id
}

// ClearFiles clears the "files" edge to the Files entity.
func (m *FilesExtendMutation) ClearFiles() {
	m.clearedfiles = true
	m.clearedFields[filesextend.FieldFileID] = struct{}{}
}

// FilesCleared reports if the "files" edge to the Files entity was cleared.
func (m *FilesExtendMutation) FilesCleared() bool {
	return m.FileIDCleared() || m.clearedfiles
}

// FilesID returns the "files" edge ID in the mutation.
func (m *FilesExtendMutation) FilesID() (id string, exists bool) {
	if m.files != nil {
		return *m.files, true
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FilesID instead. It exists only for internal usage by the builders.
func (m *FilesExtendMutation) FilesIDs() (ids []string) {
	if id := m.files; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *FilesExtendMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
}

// Where appends a list predicates to the FilesExtendMutation builder.
func (m *FilesExtendMutation) Where(ps ...predicate.FilesExtend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesExtendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesExtendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FilesExtend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesExtendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesExtendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FilesExtend).
func (m *FilesExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesExtendMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.files != nil {
		fields = append(fields, filesextend.FieldFileID)
	}
	if m.user_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.from != nil {
		fields = append(fields, filesextend.FieldFrom)
	}
	if m.from_id != nil {
		fields = append(fields, filesextend.FieldFromID)
	}
	if m.is_hidden != nil {
		fields = append(fields, filesextend.FieldIsHidden)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.CreatedAt()
	case filesextend.FieldCreatedBy:
		return m.CreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.UpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.UpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.DeletedAt()
	case filesextend.FieldDeletedBy:
		return m.DeletedBy()
	case filesextend.FieldFileID:
		return m.FileID()
	case filesextend.FieldUserID:
		return m.UserID()
	case filesextend.FieldFrom:
		return m.From()
	case filesextend.FieldFromID:
		return m.FromID()
	case filesextend.FieldIsHidden:
		return m.IsHidden()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filesextend.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filesextend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filesextend.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filesextend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case filesextend.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case filesextend.FieldFileID:
		return m.OldFileID(ctx)
	case filesextend.FieldUserID:
		return m.OldUserID(ctx)
	case filesextend.FieldFrom:
		return m.OldFrom(ctx)
	case filesextend.FieldFromID:
		return m.OldFromID(ctx)
	case filesextend.FieldIsHidden:
		return m.OldIsHidden(ctx)
	}
	return nil, fmt.Errorf("unknown FilesExtend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case filesextend.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case filesextend.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case filesextend.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromID(v)
		return nil
	case filesextend.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesExtendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.addfrom_id != nil {
		fields = append(fields, filesextend.FieldFromID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesExtendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case filesextend.FieldCreatedBy:
		return m.AddedCreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.AddedDeletedAt()
	case filesextend.FieldDeletedBy:
		return m.AddedDeletedBy()
	case filesextend.FieldUserID:
		return m.AddedUserID()
	case filesextend.FieldFromID:
		return m.AddedFromID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case filesextend.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromID(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesExtendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filesextend.FieldFileID) {
		fields = append(fields, filesextend.FieldFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesExtendMutation) ClearField(name string) error {
	switch name {
	case filesextend.FieldFileID:
		m.ClearFileID()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesExtendMutation) ResetField(name string) error {
	switch name {
	case filesextend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filesextend.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filesextend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filesextend.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filesextend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case filesextend.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case filesextend.FieldFileID:
		m.ResetFileID()
		return nil
	case filesextend.FieldUserID:
		m.ResetUserID()
		return nil
	case filesextend.FieldFrom:
		m.ResetFrom()
		return nil
	case filesextend.FieldFromID:
		m.ResetFromID()
		return nil
	case filesextend.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.files != nil {
		edges = append(edges, filesextend.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesExtendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filesextend.EdgeFiles:
		if id := m.files; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfiles {
		edges = append(edges, filesextend.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesExtendMutation) EdgeCleared(name string) bool {
	switch name {
	case filesextend.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesExtendMutation) ClearEdge(name string) error {
	switch name {
	case filesextend.EdgeFiles:
		m.ClearFiles()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesExtendMutation) ResetEdge(name string) error {
	switch name {
	case filesextend.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend edge %s", name)
}

// PalacesMemoMutation represents an operation that mutates the PalacesMemo nodes in the graph.
type PalacesMemoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	name          *string
	content       *string
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PalacesMemo, error)
	predicates    []predicate.PalacesMemo
}

var _ ent.Mutation = (*PalacesMemoMutation)(nil)

// palacesmemoOption allows management of the mutation configuration using functional options.
type palacesmemoOption func(*PalacesMemoMutation)

// newPalacesMemoMutation creates new mutation for the PalacesMemo entity.
func newPalacesMemoMutation(c config, op Op, opts ...palacesmemoOption) *PalacesMemoMutation {
	m := &PalacesMemoMutation{
		config:        c,
		op:            op,
		typ:           TypePalacesMemo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPalacesMemoID sets the ID field of the mutation.
func withPalacesMemoID(id int) palacesmemoOption {
	return func(m *PalacesMemoMutation) {
		var (
			err   error
			once  sync.Once
			value *PalacesMemo
		)
		m.oldValue = func(ctx context.Context) (*PalacesMemo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PalacesMemo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPalacesMemo sets the old PalacesMemo of the mutation.
func withPalacesMemo(node *PalacesMemo) palacesmemoOption {
	return func(m *PalacesMemoMutation) {
		m.oldValue = func(context.Context) (*PalacesMemo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PalacesMemoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PalacesMemoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PalacesMemo entities.
func (m *PalacesMemoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PalacesMemoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PalacesMemoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PalacesMemo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PalacesMemoMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PalacesMemoMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PalacesMemoMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PalacesMemoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PalacesMemoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PalacesMemoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PalacesMemoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PalacesMemoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PalacesMemoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PalacesMemoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PalacesMemoMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PalacesMemoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PalacesMemoMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PalacesMemoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PalacesMemoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PalacesMemoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PalacesMemoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PalacesMemoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PalacesMemoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PalacesMemoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PalacesMemoMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PalacesMemoMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PalacesMemoMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PalacesMemoMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PalacesMemoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PalacesMemoMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PalacesMemoMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PalacesMemoMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PalacesMemoMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PalacesMemoMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *PalacesMemoMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PalacesMemoMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *PalacesMemoMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *PalacesMemoMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PalacesMemoMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetName sets the "name" field.
func (m *PalacesMemoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PalacesMemoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PalacesMemoMutation) ResetName() {
	m.name = nil
}

// SetContent sets the "content" field.
func (m *PalacesMemoMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PalacesMemoMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PalacesMemoMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *PalacesMemoMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PalacesMemoMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PalacesMemo entity.
// If the PalacesMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PalacesMemoMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PalacesMemoMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PalacesMemoMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the PalacesMemoMutation builder.
func (m *PalacesMemoMutation) Where(ps ...predicate.PalacesMemo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PalacesMemoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PalacesMemoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PalacesMemo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PalacesMemoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PalacesMemoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PalacesMemo).
func (m *PalacesMemoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PalacesMemoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, palacesmemo.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, palacesmemo.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, palacesmemo.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, palacesmemo.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, palacesmemo.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, palacesmemo.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, palacesmemo.FieldAccountID)
	}
	if m.name != nil {
		fields = append(fields, palacesmemo.FieldName)
	}
	if m.content != nil {
		fields = append(fields, palacesmemo.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, palacesmemo.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PalacesMemoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case palacesmemo.FieldCreatedAt:
		return m.CreatedAt()
	case palacesmemo.FieldCreatedBy:
		return m.CreatedBy()
	case palacesmemo.FieldUpdatedAt:
		return m.UpdatedAt()
	case palacesmemo.FieldUpdatedBy:
		return m.UpdatedBy()
	case palacesmemo.FieldDeletedAt:
		return m.DeletedAt()
	case palacesmemo.FieldDeletedBy:
		return m.DeletedBy()
	case palacesmemo.FieldAccountID:
		return m.AccountID()
	case palacesmemo.FieldName:
		return m.Name()
	case palacesmemo.FieldContent:
		return m.Content()
	case palacesmemo.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PalacesMemoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case palacesmemo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case palacesmemo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case palacesmemo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case palacesmemo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case palacesmemo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case palacesmemo.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case palacesmemo.FieldAccountID:
		return m.OldAccountID(ctx)
	case palacesmemo.FieldName:
		return m.OldName(ctx)
	case palacesmemo.FieldContent:
		return m.OldContent(ctx)
	case palacesmemo.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PalacesMemo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesMemoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case palacesmemo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case palacesmemo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case palacesmemo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case palacesmemo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case palacesmemo.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case palacesmemo.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case palacesmemo.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case palacesmemo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case palacesmemo.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case palacesmemo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesMemo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PalacesMemoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, palacesmemo.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, palacesmemo.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, palacesmemo.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, palacesmemo.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, palacesmemo.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, palacesmemo.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, palacesmemo.FieldAccountID)
	}
	if m.addstatus != nil {
		fields = append(fields, palacesmemo.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PalacesMemoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case palacesmemo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case palacesmemo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case palacesmemo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case palacesmemo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case palacesmemo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case palacesmemo.FieldDeletedBy:
		return m.AddedDeletedBy()
	case palacesmemo.FieldAccountID:
		return m.AddedAccountID()
	case palacesmemo.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesMemoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case palacesmemo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case palacesmemo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case palacesmemo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case palacesmemo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case palacesmemo.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case palacesmemo.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case palacesmemo.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case palacesmemo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesMemo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PalacesMemoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PalacesMemoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PalacesMemoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PalacesMemo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PalacesMemoMutation) ResetField(name string) error {
	switch name {
	case palacesmemo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case palacesmemo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case palacesmemo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case palacesmemo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case palacesmemo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case palacesmemo.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case palacesmemo.FieldAccountID:
		m.ResetAccountID()
		return nil
	case palacesmemo.FieldName:
		m.ResetName()
		return nil
	case palacesmemo.FieldContent:
		m.ResetContent()
		return nil
	case palacesmemo.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PalacesMemo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PalacesMemoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PalacesMemoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PalacesMemoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PalacesMemoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PalacesMemoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PalacesMemoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PalacesMemoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PalacesMemo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PalacesMemoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PalacesMemo edge %s", name)
}

// PalacesMemoryMutation represents an operation that mutates the PalacesMemory nodes in the graph.
type PalacesMemoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PalacesMemory, error)
	predicates    []predicate.PalacesMemory
}

var _ ent.Mutation = (*PalacesMemoryMutation)(nil)

// palacesmemoryOption allows management of the mutation configuration using functional options.
type palacesmemoryOption func(*PalacesMemoryMutation)

// newPalacesMemoryMutation creates new mutation for the PalacesMemory entity.
func newPalacesMemoryMutation(c config, op Op, opts ...palacesmemoryOption) *PalacesMemoryMutation {
	m := &PalacesMemoryMutation{
		config:        c,
		op:            op,
		typ:           TypePalacesMemory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPalacesMemoryID sets the ID field of the mutation.
func withPalacesMemoryID(id int) palacesmemoryOption {
	return func(m *PalacesMemoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PalacesMemory
		)
		m.oldValue = func(ctx context.Context) (*PalacesMemory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PalacesMemory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPalacesMemory sets the old PalacesMemory of the mutation.
func withPalacesMemory(node *PalacesMemory) palacesmemoryOption {
	return func(m *PalacesMemoryMutation) {
		m.oldValue = func(context.Context) (*PalacesMemory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PalacesMemoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PalacesMemoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PalacesMemory entities.
func (m *PalacesMemoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PalacesMemoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PalacesMemoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PalacesMemory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PalacesMemoryMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PalacesMemoryMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PalacesMemoryMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PalacesMemoryMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PalacesMemoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PalacesMemoryMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PalacesMemoryMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PalacesMemoryMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PalacesMemoryMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PalacesMemoryMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PalacesMemoryMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PalacesMemoryMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PalacesMemoryMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PalacesMemoryMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PalacesMemoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PalacesMemoryMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PalacesMemoryMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PalacesMemoryMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PalacesMemoryMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PalacesMemoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PalacesMemoryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PalacesMemoryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PalacesMemoryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PalacesMemoryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PalacesMemoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PalacesMemoryMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PalacesMemoryMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PalacesMemoryMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PalacesMemoryMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PalacesMemoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetStatus sets the "status" field.
func (m *PalacesMemoryMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PalacesMemoryMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PalacesMemory entity.
// If the PalacesMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesMemoryMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PalacesMemoryMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PalacesMemoryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PalacesMemoryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the PalacesMemoryMutation builder.
func (m *PalacesMemoryMutation) Where(ps ...predicate.PalacesMemory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PalacesMemoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PalacesMemoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PalacesMemory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PalacesMemoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PalacesMemoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PalacesMemory).
func (m *PalacesMemoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PalacesMemoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, palacesmemory.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, palacesmemory.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, palacesmemory.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, palacesmemory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, palacesmemory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, palacesmemory.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, palacesmemory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PalacesMemoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case palacesmemory.FieldCreatedAt:
		return m.CreatedAt()
	case palacesmemory.FieldCreatedBy:
		return m.CreatedBy()
	case palacesmemory.FieldUpdatedAt:
		return m.UpdatedAt()
	case palacesmemory.FieldUpdatedBy:
		return m.UpdatedBy()
	case palacesmemory.FieldDeletedAt:
		return m.DeletedAt()
	case palacesmemory.FieldDeletedBy:
		return m.DeletedBy()
	case palacesmemory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PalacesMemoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case palacesmemory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case palacesmemory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case palacesmemory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case palacesmemory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case palacesmemory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case palacesmemory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case palacesmemory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PalacesMemory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesMemoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case palacesmemory.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case palacesmemory.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case palacesmemory.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case palacesmemory.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case palacesmemory.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case palacesmemory.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case palacesmemory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesMemory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PalacesMemoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, palacesmemory.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, palacesmemory.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, palacesmemory.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, palacesmemory.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, palacesmemory.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, palacesmemory.FieldDeletedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, palacesmemory.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PalacesMemoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case palacesmemory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case palacesmemory.FieldCreatedBy:
		return m.AddedCreatedBy()
	case palacesmemory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case palacesmemory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case palacesmemory.FieldDeletedAt:
		return m.AddedDeletedAt()
	case palacesmemory.FieldDeletedBy:
		return m.AddedDeletedBy()
	case palacesmemory.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesMemoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case palacesmemory.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case palacesmemory.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case palacesmemory.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case palacesmemory.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case palacesmemory.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case palacesmemory.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case palacesmemory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesMemory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PalacesMemoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PalacesMemoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PalacesMemoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PalacesMemory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PalacesMemoryMutation) ResetField(name string) error {
	switch name {
	case palacesmemory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case palacesmemory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case palacesmemory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case palacesmemory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case palacesmemory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case palacesmemory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case palacesmemory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PalacesMemory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PalacesMemoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PalacesMemoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PalacesMemoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PalacesMemoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PalacesMemoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PalacesMemoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PalacesMemoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PalacesMemory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PalacesMemoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PalacesMemory edge %s", name)
}

// PalacesTodoMutation represents an operation that mutates the PalacesTodo nodes in the graph.
type PalacesTodoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	theme         *string
	_type         *int8
	add_type      *int8
	from          *int64
	addfrom       *int64
	to            *int64
	addto         *int64
	num           *int64
	addnum        *int64
	sort          *int64
	addsort       *int64
	content       *string
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	dones         map[int]struct{}
	removeddones  map[int]struct{}
	cleareddones  bool
	done          bool
	oldValue      func(context.Context) (*PalacesTodo, error)
	predicates    []predicate.PalacesTodo
}

var _ ent.Mutation = (*PalacesTodoMutation)(nil)

// palacestodoOption allows management of the mutation configuration using functional options.
type palacestodoOption func(*PalacesTodoMutation)

// newPalacesTodoMutation creates new mutation for the PalacesTodo entity.
func newPalacesTodoMutation(c config, op Op, opts ...palacestodoOption) *PalacesTodoMutation {
	m := &PalacesTodoMutation{
		config:        c,
		op:            op,
		typ:           TypePalacesTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPalacesTodoID sets the ID field of the mutation.
func withPalacesTodoID(id int) palacestodoOption {
	return func(m *PalacesTodoMutation) {
		var (
			err   error
			once  sync.Once
			value *PalacesTodo
		)
		m.oldValue = func(ctx context.Context) (*PalacesTodo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PalacesTodo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPalacesTodo sets the old PalacesTodo of the mutation.
func withPalacesTodo(node *PalacesTodo) palacestodoOption {
	return func(m *PalacesTodoMutation) {
		m.oldValue = func(context.Context) (*PalacesTodo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PalacesTodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PalacesTodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PalacesTodo entities.
func (m *PalacesTodoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PalacesTodoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PalacesTodoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PalacesTodo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PalacesTodoMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PalacesTodoMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PalacesTodoMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PalacesTodoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PalacesTodoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PalacesTodoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PalacesTodoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PalacesTodoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PalacesTodoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PalacesTodoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PalacesTodoMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PalacesTodoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PalacesTodoMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PalacesTodoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PalacesTodoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PalacesTodoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PalacesTodoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PalacesTodoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PalacesTodoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PalacesTodoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PalacesTodoMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PalacesTodoMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PalacesTodoMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PalacesTodoMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PalacesTodoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PalacesTodoMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PalacesTodoMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PalacesTodoMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PalacesTodoMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PalacesTodoMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *PalacesTodoMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PalacesTodoMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *PalacesTodoMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *PalacesTodoMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PalacesTodoMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTheme sets the "theme" field.
func (m *PalacesTodoMutation) SetTheme(s string) {
	m.theme = &s
}

// Theme returns the value of the "theme" field in the mutation.
func (m *PalacesTodoMutation) Theme() (r string, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldTheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ResetTheme resets all changes to the "theme" field.
func (m *PalacesTodoMutation) ResetTheme() {
	m.theme = nil
}

// SetType sets the "type" field.
func (m *PalacesTodoMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PalacesTodoMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *PalacesTodoMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PalacesTodoMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PalacesTodoMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetFrom sets the "from" field.
func (m *PalacesTodoMutation) SetFrom(i int64) {
	m.from = &i
	m.addfrom = nil
}

// From returns the value of the "from" field in the mutation.
func (m *PalacesTodoMutation) From() (r int64, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldFrom(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// AddFrom adds i to the "from" field.
func (m *PalacesTodoMutation) AddFrom(i int64) {
	if m.addfrom != nil {
		*m.addfrom += i
	} else {
		m.addfrom = &i
	}
}

// AddedFrom returns the value that was added to the "from" field in this mutation.
func (m *PalacesTodoMutation) AddedFrom() (r int64, exists bool) {
	v := m.addfrom
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrom resets all changes to the "from" field.
func (m *PalacesTodoMutation) ResetFrom() {
	m.from = nil
	m.addfrom = nil
}

// SetTo sets the "to" field.
func (m *PalacesTodoMutation) SetTo(i int64) {
	m.to = &i
	m.addto = nil
}

// To returns the value of the "to" field in the mutation.
func (m *PalacesTodoMutation) To() (r int64, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldTo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// AddTo adds i to the "to" field.
func (m *PalacesTodoMutation) AddTo(i int64) {
	if m.addto != nil {
		*m.addto += i
	} else {
		m.addto = &i
	}
}

// AddedTo returns the value that was added to the "to" field in this mutation.
func (m *PalacesTodoMutation) AddedTo() (r int64, exists bool) {
	v := m.addto
	if v == nil {
		return
	}
	return *v, true
}

// ResetTo resets all changes to the "to" field.
func (m *PalacesTodoMutation) ResetTo() {
	m.to = nil
	m.addto = nil
}

// SetNum sets the "num" field.
func (m *PalacesTodoMutation) SetNum(i int64) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *PalacesTodoMutation) Num() (r int64, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *PalacesTodoMutation) AddNum(i int64) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *PalacesTodoMutation) AddedNum() (r int64, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *PalacesTodoMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetSort sets the "sort" field.
func (m *PalacesTodoMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PalacesTodoMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PalacesTodoMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PalacesTodoMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PalacesTodoMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetContent sets the "content" field.
func (m *PalacesTodoMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PalacesTodoMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PalacesTodoMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *PalacesTodoMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PalacesTodoMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PalacesTodo entity.
// If the PalacesTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PalacesTodoMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PalacesTodoMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PalacesTodoMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddDoneIDs adds the "dones" edge to the PalacesTodoDone entity by ids.
func (m *PalacesTodoMutation) AddDoneIDs(ids ...int) {
	if m.dones == nil {
		m.dones = make(map[int]struct{})
	}
	for i := range ids {
		m.dones[ids[i]] = struct{}{}
	}
}

// ClearDones clears the "dones" edge to the PalacesTodoDone entity.
func (m *PalacesTodoMutation) ClearDones() {
	m.cleareddones = true
}

// DonesCleared reports if the "dones" edge to the PalacesTodoDone entity was cleared.
func (m *PalacesTodoMutation) DonesCleared() bool {
	return m.cleareddones
}

// RemoveDoneIDs removes the "dones" edge to the PalacesTodoDone entity by IDs.
func (m *PalacesTodoMutation) RemoveDoneIDs(ids ...int) {
	if m.removeddones == nil {
		m.removeddones = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dones, ids[i])
		m.removeddones[ids[i]] = struct{}{}
	}
}

// RemovedDones returns the removed IDs of the "dones" edge to the PalacesTodoDone entity.
func (m *PalacesTodoMutation) RemovedDonesIDs() (ids []int) {
	for id := range m.removeddones {
		ids = append(ids, id)
	}
	return
}

// DonesIDs returns the "dones" edge IDs in the mutation.
func (m *PalacesTodoMutation) DonesIDs() (ids []int) {
	for id := range m.dones {
		ids = append(ids, id)
	}
	return
}

// ResetDones resets all changes to the "dones" edge.
func (m *PalacesTodoMutation) ResetDones() {
	m.dones = nil
	m.cleareddones = false
	m.removeddones = nil
}

// Where appends a list predicates to the PalacesTodoMutation builder.
func (m *PalacesTodoMutation) Where(ps ...predicate.PalacesTodo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PalacesTodoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PalacesTodoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PalacesTodo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PalacesTodoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PalacesTodoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PalacesTodo).
func (m *PalacesTodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PalacesTodoMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, palacestodo.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, palacestodo.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, palacestodo.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, palacestodo.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, palacestodo.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, palacestodo.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, palacestodo.FieldAccountID)
	}
	if m.theme != nil {
		fields = append(fields, palacestodo.FieldTheme)
	}
	if m._type != nil {
		fields = append(fields, palacestodo.FieldType)
	}
	if m.from != nil {
		fields = append(fields, palacestodo.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, palacestodo.FieldTo)
	}
	if m.num != nil {
		fields = append(fields, palacestodo.FieldNum)
	}
	if m.sort != nil {
		fields = append(fields, palacestodo.FieldSort)
	}
	if m.content != nil {
		fields = append(fields, palacestodo.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, palacestodo.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PalacesTodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case palacestodo.FieldCreatedAt:
		return m.CreatedAt()
	case palacestodo.FieldCreatedBy:
		return m.CreatedBy()
	case palacestodo.FieldUpdatedAt:
		return m.UpdatedAt()
	case palacestodo.FieldUpdatedBy:
		return m.UpdatedBy()
	case palacestodo.FieldDeletedAt:
		return m.DeletedAt()
	case palacestodo.FieldDeletedBy:
		return m.DeletedBy()
	case palacestodo.FieldAccountID:
		return m.AccountID()
	case palacestodo.FieldTheme:
		return m.Theme()
	case palacestodo.FieldType:
		return m.GetType()
	case palacestodo.FieldFrom:
		return m.From()
	case palacestodo.FieldTo:
		return m.To()
	case palacestodo.FieldNum:
		return m.Num()
	case palacestodo.FieldSort:
		return m.Sort()
	case palacestodo.FieldContent:
		return m.Content()
	case palacestodo.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PalacesTodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case palacestodo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case palacestodo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case palacestodo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case palacestodo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case palacestodo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case palacestodo.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case palacestodo.FieldAccountID:
		return m.OldAccountID(ctx)
	case palacestodo.FieldTheme:
		return m.OldTheme(ctx)
	case palacestodo.FieldType:
		return m.OldType(ctx)
	case palacestodo.FieldFrom:
		return m.OldFrom(ctx)
	case palacestodo.FieldTo:
		return m.OldTo(ctx)
	case palacestodo.FieldNum:
		return m.OldNum(ctx)
	case palacestodo.FieldSort:
		return m.OldSort(ctx)
	case palacestodo.FieldContent:
		return m.OldContent(ctx)
	case palacestodo.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PalacesTodo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesTodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case palacestodo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case palacestodo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case palacestodo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case palacestodo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case palacestodo.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case palacestodo.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case palacestodo.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case palacestodo.FieldTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case palacestodo.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case palacestodo.FieldFrom:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case palacestodo.FieldTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case palacestodo.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case palacestodo.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case palacestodo.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case palacestodo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesTodo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PalacesTodoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, palacestodo.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, palacestodo.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, palacestodo.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, palacestodo.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, palacestodo.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, palacestodo.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, palacestodo.FieldAccountID)
	}
	if m.add_type != nil {
		fields = append(fields, palacestodo.FieldType)
	}
	if m.addfrom != nil {
		fields = append(fields, palacestodo.FieldFrom)
	}
	if m.addto != nil {
		fields = append(fields, palacestodo.FieldTo)
	}
	if m.addnum != nil {
		fields = append(fields, palacestodo.FieldNum)
	}
	if m.addsort != nil {
		fields = append(fields, palacestodo.FieldSort)
	}
	if m.addstatus != nil {
		fields = append(fields, palacestodo.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PalacesTodoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case palacestodo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case palacestodo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case palacestodo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case palacestodo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case palacestodo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case palacestodo.FieldDeletedBy:
		return m.AddedDeletedBy()
	case palacestodo.FieldAccountID:
		return m.AddedAccountID()
	case palacestodo.FieldType:
		return m.AddedType()
	case palacestodo.FieldFrom:
		return m.AddedFrom()
	case palacestodo.FieldTo:
		return m.AddedTo()
	case palacestodo.FieldNum:
		return m.AddedNum()
	case palacestodo.FieldSort:
		return m.AddedSort()
	case palacestodo.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesTodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case palacestodo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case palacestodo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case palacestodo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case palacestodo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case palacestodo.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case palacestodo.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case palacestodo.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case palacestodo.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case palacestodo.FieldFrom:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrom(v)
		return nil
	case palacestodo.FieldTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTo(v)
		return nil
	case palacestodo.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case palacestodo.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case palacestodo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesTodo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PalacesTodoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PalacesTodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PalacesTodoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PalacesTodo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PalacesTodoMutation) ResetField(name string) error {
	switch name {
	case palacestodo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case palacestodo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case palacestodo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case palacestodo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case palacestodo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case palacestodo.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case palacestodo.FieldAccountID:
		m.ResetAccountID()
		return nil
	case palacestodo.FieldTheme:
		m.ResetTheme()
		return nil
	case palacestodo.FieldType:
		m.ResetType()
		return nil
	case palacestodo.FieldFrom:
		m.ResetFrom()
		return nil
	case palacestodo.FieldTo:
		m.ResetTo()
		return nil
	case palacestodo.FieldNum:
		m.ResetNum()
		return nil
	case palacestodo.FieldSort:
		m.ResetSort()
		return nil
	case palacestodo.FieldContent:
		m.ResetContent()
		return nil
	case palacestodo.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PalacesTodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dones != nil {
		edges = append(edges, palacestodo.EdgeDones)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PalacesTodoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case palacestodo.EdgeDones:
		ids := make([]ent.Value, 0, len(m.dones))
		for id := range m.dones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PalacesTodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddones != nil {
		edges = append(edges, palacestodo.EdgeDones)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PalacesTodoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case palacestodo.EdgeDones:
		ids := make([]ent.Value, 0, len(m.removeddones))
		for id := range m.removeddones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PalacesTodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddones {
		edges = append(edges, palacestodo.EdgeDones)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PalacesTodoMutation) EdgeCleared(name string) bool {
	switch name {
	case palacestodo.EdgeDones:
		return m.cleareddones
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PalacesTodoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PalacesTodo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PalacesTodoMutation) ResetEdge(name string) error {
	switch name {
	case palacestodo.EdgeDones:
		m.ResetDones()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodo edge %s", name)
}

// PalacesTodoDoneMutation represents an operation that mutates the PalacesTodoDone nodes in the graph.
type PalacesTodoDoneMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PalacesTodoDone, error)
	predicates    []predicate.PalacesTodoDone
}

var _ ent.Mutation = (*PalacesTodoDoneMutation)(nil)

// palacestododoneOption allows management of the mutation configuration using functional options.
type palacestododoneOption func(*PalacesTodoDoneMutation)

// newPalacesTodoDoneMutation creates new mutation for the PalacesTodoDone entity.
func newPalacesTodoDoneMutation(c config, op Op, opts ...palacestododoneOption) *PalacesTodoDoneMutation {
	m := &PalacesTodoDoneMutation{
		config:        c,
		op:            op,
		typ:           TypePalacesTodoDone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPalacesTodoDoneID sets the ID field of the mutation.
func withPalacesTodoDoneID(id int) palacestododoneOption {
	return func(m *PalacesTodoDoneMutation) {
		var (
			err   error
			once  sync.Once
			value *PalacesTodoDone
		)
		m.oldValue = func(ctx context.Context) (*PalacesTodoDone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PalacesTodoDone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPalacesTodoDone sets the old PalacesTodoDone of the mutation.
func withPalacesTodoDone(node *PalacesTodoDone) palacestododoneOption {
	return func(m *PalacesTodoDoneMutation) {
		m.oldValue = func(context.Context) (*PalacesTodoDone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PalacesTodoDoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PalacesTodoDoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PalacesTodoDone entities.
func (m *PalacesTodoDoneMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PalacesTodoDoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PalacesTodoDoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PalacesTodoDone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PalacesTodoDoneMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PalacesTodoDoneMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PalacesTodoDoneMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PalacesTodoDoneMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PalacesTodoDoneMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PalacesTodoDoneMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PalacesTodoDoneMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PalacesTodoDoneMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PalacesTodoDoneMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PalacesTodoDoneMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PalacesTodoDoneMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PalacesTodoDoneMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PalacesTodoDoneMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PalacesTodoDoneMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PalacesTodoDoneMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PalacesTodoDoneMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PalacesTodoDoneMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PalacesTodoDoneMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PalacesTodoDoneMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PalacesTodoDoneMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PalacesTodoDoneMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PalacesTodoDoneMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PalacesTodoDoneMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PalacesTodoDoneMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PalacesTodoDoneMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetTodoID sets the "todo_id" field.
func (m *PalacesTodoDoneMutation) SetTodoID(i int) {
	m.owner = &i
}

// TodoID returns the value of the "todo_id" field in the mutation.
func (m *PalacesTodoDoneMutation) TodoID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldTodoID returns the old "todo_id" field's value of the PalacesTodoDone entity.
// If the PalacesTodoDone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalacesTodoDoneMutation) OldTodoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTodoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTodoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTodoID: %w", err)
	}
	return oldValue.TodoID, nil
}

// ClearTodoID clears the value of the "todo_id" field.
func (m *PalacesTodoDoneMutation) ClearTodoID() {
	m.owner = nil
	m.clearedFields[palacestododone.FieldTodoID] = struct{}{}
}

// TodoIDCleared returns if the "todo_id" field was cleared in this mutation.
func (m *PalacesTodoDoneMutation) TodoIDCleared() bool {
	_, ok := m.clearedFields[palacestododone.FieldTodoID]
	return ok
}

// ResetTodoID resets all changes to the "todo_id" field.
func (m *PalacesTodoDoneMutation) ResetTodoID() {
	m.owner = nil
	delete(m.clearedFields, palacestododone.FieldTodoID)
}

// SetOwnerID sets the "owner" edge to the PalacesTodo entity by id.
func (m *PalacesTodoDoneMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the PalacesTodo entity.
func (m *PalacesTodoDoneMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[palacestododone.FieldTodoID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the PalacesTodo entity was cleared.
func (m *PalacesTodoDoneMutation) OwnerCleared() bool {
	return m.TodoIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PalacesTodoDoneMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PalacesTodoDoneMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PalacesTodoDoneMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PalacesTodoDoneMutation builder.
func (m *PalacesTodoDoneMutation) Where(ps ...predicate.PalacesTodoDone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PalacesTodoDoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PalacesTodoDoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PalacesTodoDone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PalacesTodoDoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PalacesTodoDoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PalacesTodoDone).
func (m *PalacesTodoDoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PalacesTodoDoneMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, palacestododone.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, palacestododone.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, palacestododone.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, palacestododone.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, palacestododone.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, palacestododone.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, palacestododone.FieldTodoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PalacesTodoDoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case palacestododone.FieldCreatedAt:
		return m.CreatedAt()
	case palacestododone.FieldCreatedBy:
		return m.CreatedBy()
	case palacestododone.FieldUpdatedAt:
		return m.UpdatedAt()
	case palacestododone.FieldUpdatedBy:
		return m.UpdatedBy()
	case palacestododone.FieldDeletedAt:
		return m.DeletedAt()
	case palacestododone.FieldDeletedBy:
		return m.DeletedBy()
	case palacestododone.FieldTodoID:
		return m.TodoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PalacesTodoDoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case palacestododone.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case palacestododone.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case palacestododone.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case palacestododone.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case palacestododone.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case palacestododone.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case palacestododone.FieldTodoID:
		return m.OldTodoID(ctx)
	}
	return nil, fmt.Errorf("unknown PalacesTodoDone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesTodoDoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case palacestododone.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case palacestododone.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case palacestododone.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case palacestododone.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case palacestododone.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case palacestododone.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case palacestododone.FieldTodoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTodoID(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PalacesTodoDoneMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, palacestododone.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, palacestododone.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, palacestododone.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, palacestododone.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, palacestododone.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, palacestododone.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PalacesTodoDoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case palacestododone.FieldCreatedAt:
		return m.AddedCreatedAt()
	case palacestododone.FieldCreatedBy:
		return m.AddedCreatedBy()
	case palacestododone.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case palacestododone.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case palacestododone.FieldDeletedAt:
		return m.AddedDeletedAt()
	case palacestododone.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalacesTodoDoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case palacestododone.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case palacestododone.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case palacestododone.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case palacestododone.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case palacestododone.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case palacestododone.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PalacesTodoDoneMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(palacestododone.FieldTodoID) {
		fields = append(fields, palacestododone.FieldTodoID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PalacesTodoDoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PalacesTodoDoneMutation) ClearField(name string) error {
	switch name {
	case palacestododone.FieldTodoID:
		m.ClearTodoID()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PalacesTodoDoneMutation) ResetField(name string) error {
	switch name {
	case palacestododone.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case palacestododone.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case palacestododone.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case palacestododone.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case palacestododone.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case palacestododone.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case palacestododone.FieldTodoID:
		m.ResetTodoID()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PalacesTodoDoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, palacestododone.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PalacesTodoDoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case palacestododone.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PalacesTodoDoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PalacesTodoDoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PalacesTodoDoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, palacestododone.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PalacesTodoDoneMutation) EdgeCleared(name string) bool {
	switch name {
	case palacestododone.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PalacesTodoDoneMutation) ClearEdge(name string) error {
	switch name {
	case palacestododone.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PalacesTodoDoneMutation) ResetEdge(name string) error {
	switch name {
	case palacestododone.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PalacesTodoDone edge %s", name)
}

// TagsMutation represents an operation that mutates the Tags nodes in the graph.
type TagsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *int64
	addcreated_at       *int64
	created_by          *int64
	addcreated_by       *int64
	updated_at          *int64
	addupdated_at       *int64
	updated_by          *int64
	addupdated_by       *int64
	deleted_at          *int64
	adddeleted_at       *int64
	deleted_by          *int64
	adddeleted_by       *int64
	name                *string
	clearedFields       map[string]struct{}
	blogs               map[int]struct{}
	removedblogs        map[int]struct{}
	clearedblogs        bool
	tag_relation        map[int]struct{}
	removedtag_relation map[int]struct{}
	clearedtag_relation bool
	done                bool
	oldValue            func(context.Context) (*Tags, error)
	predicates          []predicate.Tags
}

var _ ent.Mutation = (*TagsMutation)(nil)

// tagsOption allows management of the mutation configuration using functional options.
type tagsOption func(*TagsMutation)

// newTagsMutation creates new mutation for the Tags entity.
func newTagsMutation(c config, op Op, opts ...tagsOption) *TagsMutation {
	m := &TagsMutation{
		config:        c,
		op:            op,
		typ:           TypeTags,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagsID sets the ID field of the mutation.
func withTagsID(id int) tagsOption {
	return func(m *TagsMutation) {
		var (
			err   error
			once  sync.Once
			value *Tags
		)
		m.oldValue = func(ctx context.Context) (*Tags, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tags.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTags sets the old Tags of the mutation.
func withTags(node *Tags) tagsOption {
	return func(m *TagsMutation) {
		m.oldValue = func(context.Context) (*Tags, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tags entities.
func (m *TagsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tags.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TagsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TagsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TagsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TagsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TagsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TagsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TagsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TagsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TagsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TagsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TagsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TagsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TagsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TagsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TagsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TagsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TagsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TagsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TagsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TagsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TagsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetName sets the "name" field.
func (m *TagsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tags entity.
// If the Tags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagsMutation) ResetName() {
	m.name = nil
}

// AddBlogIDs adds the "blogs" edge to the Blogs entity by ids.
func (m *TagsMutation) AddBlogIDs(ids ...int) {
	if m.blogs == nil {
		m.blogs = make(map[int]struct{})
	}
	for i := range ids {
		m.blogs[ids[i]] = struct{}{}
	}
}

// ClearBlogs clears the "blogs" edge to the Blogs entity.
func (m *TagsMutation) ClearBlogs() {
	m.clearedblogs = true
}

// BlogsCleared reports if the "blogs" edge to the Blogs entity was cleared.
func (m *TagsMutation) BlogsCleared() bool {
	return m.clearedblogs
}

// RemoveBlogIDs removes the "blogs" edge to the Blogs entity by IDs.
func (m *TagsMutation) RemoveBlogIDs(ids ...int) {
	if m.removedblogs == nil {
		m.removedblogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blogs, ids[i])
		m.removedblogs[ids[i]] = struct{}{}
	}
}

// RemovedBlogs returns the removed IDs of the "blogs" edge to the Blogs entity.
func (m *TagsMutation) RemovedBlogsIDs() (ids []int) {
	for id := range m.removedblogs {
		ids = append(ids, id)
	}
	return
}

// BlogsIDs returns the "blogs" edge IDs in the mutation.
func (m *TagsMutation) BlogsIDs() (ids []int) {
	for id := range m.blogs {
		ids = append(ids, id)
	}
	return
}

// ResetBlogs resets all changes to the "blogs" edge.
func (m *TagsMutation) ResetBlogs() {
	m.blogs = nil
	m.clearedblogs = false
	m.removedblogs = nil
}

// AddTagRelationIDs adds the "tag_relation" edge to the TagsRelation entity by ids.
func (m *TagsMutation) AddTagRelationIDs(ids ...int) {
	if m.tag_relation == nil {
		m.tag_relation = make(map[int]struct{})
	}
	for i := range ids {
		m.tag_relation[ids[i]] = struct{}{}
	}
}

// ClearTagRelation clears the "tag_relation" edge to the TagsRelation entity.
func (m *TagsMutation) ClearTagRelation() {
	m.clearedtag_relation = true
}

// TagRelationCleared reports if the "tag_relation" edge to the TagsRelation entity was cleared.
func (m *TagsMutation) TagRelationCleared() bool {
	return m.clearedtag_relation
}

// RemoveTagRelationIDs removes the "tag_relation" edge to the TagsRelation entity by IDs.
func (m *TagsMutation) RemoveTagRelationIDs(ids ...int) {
	if m.removedtag_relation == nil {
		m.removedtag_relation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag_relation, ids[i])
		m.removedtag_relation[ids[i]] = struct{}{}
	}
}

// RemovedTagRelation returns the removed IDs of the "tag_relation" edge to the TagsRelation entity.
func (m *TagsMutation) RemovedTagRelationIDs() (ids []int) {
	for id := range m.removedtag_relation {
		ids = append(ids, id)
	}
	return
}

// TagRelationIDs returns the "tag_relation" edge IDs in the mutation.
func (m *TagsMutation) TagRelationIDs() (ids []int) {
	for id := range m.tag_relation {
		ids = append(ids, id)
	}
	return
}

// ResetTagRelation resets all changes to the "tag_relation" edge.
func (m *TagsMutation) ResetTagRelation() {
	m.tag_relation = nil
	m.clearedtag_relation = false
	m.removedtag_relation = nil
}

// Where appends a list predicates to the TagsMutation builder.
func (m *TagsMutation) Where(ps ...predicate.Tags) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tags, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tags).
func (m *TagsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, tags.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, tags.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, tags.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, tags.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, tags.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, tags.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, tags.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tags.FieldCreatedAt:
		return m.CreatedAt()
	case tags.FieldCreatedBy:
		return m.CreatedBy()
	case tags.FieldUpdatedAt:
		return m.UpdatedAt()
	case tags.FieldUpdatedBy:
		return m.UpdatedBy()
	case tags.FieldDeletedAt:
		return m.DeletedAt()
	case tags.FieldDeletedBy:
		return m.DeletedBy()
	case tags.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tags.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tags.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tags.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tags.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tags.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tags.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tags.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tags field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tags.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tags.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tags.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tags.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tags.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tags.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tags.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tags field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tags.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, tags.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tags.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, tags.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, tags.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, tags.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tags.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tags.FieldCreatedBy:
		return m.AddedCreatedBy()
	case tags.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case tags.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case tags.FieldDeletedAt:
		return m.AddedDeletedAt()
	case tags.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tags.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tags.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case tags.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case tags.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case tags.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case tags.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Tags numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tags nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagsMutation) ResetField(name string) error {
	switch name {
	case tags.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tags.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tags.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tags.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tags.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tags.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tags.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tags field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blogs != nil {
		edges = append(edges, tags.EdgeBlogs)
	}
	if m.tag_relation != nil {
		edges = append(edges, tags.EdgeTagRelation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tags.EdgeBlogs:
		ids := make([]ent.Value, 0, len(m.blogs))
		for id := range m.blogs {
			ids = append(ids, id)
		}
		return ids
	case tags.EdgeTagRelation:
		ids := make([]ent.Value, 0, len(m.tag_relation))
		for id := range m.tag_relation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblogs != nil {
		edges = append(edges, tags.EdgeBlogs)
	}
	if m.removedtag_relation != nil {
		edges = append(edges, tags.EdgeTagRelation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tags.EdgeBlogs:
		ids := make([]ent.Value, 0, len(m.removedblogs))
		for id := range m.removedblogs {
			ids = append(ids, id)
		}
		return ids
	case tags.EdgeTagRelation:
		ids := make([]ent.Value, 0, len(m.removedtag_relation))
		for id := range m.removedtag_relation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblogs {
		edges = append(edges, tags.EdgeBlogs)
	}
	if m.clearedtag_relation {
		edges = append(edges, tags.EdgeTagRelation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagsMutation) EdgeCleared(name string) bool {
	switch name {
	case tags.EdgeBlogs:
		return m.clearedblogs
	case tags.EdgeTagRelation:
		return m.clearedtag_relation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tags unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagsMutation) ResetEdge(name string) error {
	switch name {
	case tags.EdgeBlogs:
		m.ResetBlogs()
		return nil
	case tags.EdgeTagRelation:
		m.ResetTagRelation()
		return nil
	}
	return fmt.Errorf("unknown Tags edge %s", name)
}

// TagsRelationMutation represents an operation that mutates the TagsRelation nodes in the graph.
type TagsRelationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	relation      *string
	clearedFields map[string]struct{}
	blog          *int
	clearedblog   bool
	tag           *int
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*TagsRelation, error)
	predicates    []predicate.TagsRelation
}

var _ ent.Mutation = (*TagsRelationMutation)(nil)

// tagsrelationOption allows management of the mutation configuration using functional options.
type tagsrelationOption func(*TagsRelationMutation)

// newTagsRelationMutation creates new mutation for the TagsRelation entity.
func newTagsRelationMutation(c config, op Op, opts ...tagsrelationOption) *TagsRelationMutation {
	m := &TagsRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeTagsRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagsRelationID sets the ID field of the mutation.
func withTagsRelationID(id int) tagsrelationOption {
	return func(m *TagsRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *TagsRelation
		)
		m.oldValue = func(ctx context.Context) (*TagsRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TagsRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTagsRelation sets the old TagsRelation of the mutation.
func withTagsRelation(node *TagsRelation) tagsrelationOption {
	return func(m *TagsRelationMutation) {
		m.oldValue = func(context.Context) (*TagsRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagsRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagsRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagsRelationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagsRelationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TagsRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagID sets the "tag_id" field.
func (m *TagsRelationMutation) SetTagID(i int) {
	m.tag = &i
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TagsRelationMutation) TagID() (r int, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TagsRelation entity.
// If the TagsRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsRelationMutation) OldTagID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TagsRelationMutation) ResetTagID() {
	m.tag = nil
}

// SetRelation sets the "relation" field.
func (m *TagsRelationMutation) SetRelation(s string) {
	m.relation = &s
}

// Relation returns the value of the "relation" field in the mutation.
func (m *TagsRelationMutation) Relation() (r string, exists bool) {
	v := m.relation
	if v == nil {
		return
	}
	return *v, true
}

// OldRelation returns the old "relation" field's value of the TagsRelation entity.
// If the TagsRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsRelationMutation) OldRelation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelation: %w", err)
	}
	return oldValue.Relation, nil
}

// ResetRelation resets all changes to the "relation" field.
func (m *TagsRelationMutation) ResetRelation() {
	m.relation = nil
}

// SetRelationID sets the "relation_id" field.
func (m *TagsRelationMutation) SetRelationID(i int) {
	m.blog = &i
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *TagsRelationMutation) RelationID() (r int, exists bool) {
	v := m.blog
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the TagsRelation entity.
// If the TagsRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagsRelationMutation) OldRelationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *TagsRelationMutation) ResetRelationID() {
	m.blog = nil
}

// SetBlogID sets the "blog" edge to the Blogs entity by id.
func (m *TagsRelationMutation) SetBlogID(id int) {
	m.blog = &id
}

// ClearBlog clears the "blog" edge to the Blogs entity.
func (m *TagsRelationMutation) ClearBlog() {
	m.clearedblog = true
	m.clearedFields[tagsrelation.FieldRelationID] = struct{}{}
}

// BlogCleared reports if the "blog" edge to the Blogs entity was cleared.
func (m *TagsRelationMutation) BlogCleared() bool {
	return m.clearedblog
}

// BlogID returns the "blog" edge ID in the mutation.
func (m *TagsRelationMutation) BlogID() (id int, exists bool) {
	if m.blog != nil {
		return *m.blog, true
	}
	return
}

// BlogIDs returns the "blog" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogID instead. It exists only for internal usage by the builders.
func (m *TagsRelationMutation) BlogIDs() (ids []int) {
	if id := m.blog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlog resets all changes to the "blog" edge.
func (m *TagsRelationMutation) ResetBlog() {
	m.blog = nil
	m.clearedblog = false
}

// ClearTag clears the "tag" edge to the Tags entity.
func (m *TagsRelationMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[tagsrelation.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tags entity was cleared.
func (m *TagsRelationMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TagsRelationMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TagsRelationMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the TagsRelationMutation builder.
func (m *TagsRelationMutation) Where(ps ...predicate.TagsRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagsRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagsRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TagsRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagsRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagsRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TagsRelation).
func (m *TagsRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagsRelationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tag != nil {
		fields = append(fields, tagsrelation.FieldTagID)
	}
	if m.relation != nil {
		fields = append(fields, tagsrelation.FieldRelation)
	}
	if m.blog != nil {
		fields = append(fields, tagsrelation.FieldRelationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagsRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tagsrelation.FieldTagID:
		return m.TagID()
	case tagsrelation.FieldRelation:
		return m.Relation()
	case tagsrelation.FieldRelationID:
		return m.RelationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagsRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tagsrelation.FieldTagID:
		return m.OldTagID(ctx)
	case tagsrelation.FieldRelation:
		return m.OldRelation(ctx)
	case tagsrelation.FieldRelationID:
		return m.OldRelationID(ctx)
	}
	return nil, fmt.Errorf("unknown TagsRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tagsrelation.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case tagsrelation.FieldRelation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelation(v)
		return nil
	case tagsrelation.FieldRelationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	}
	return fmt.Errorf("unknown TagsRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagsRelationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagsRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagsRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TagsRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagsRelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagsRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagsRelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TagsRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagsRelationMutation) ResetField(name string) error {
	switch name {
	case tagsrelation.FieldTagID:
		m.ResetTagID()
		return nil
	case tagsrelation.FieldRelation:
		m.ResetRelation()
		return nil
	case tagsrelation.FieldRelationID:
		m.ResetRelationID()
		return nil
	}
	return fmt.Errorf("unknown TagsRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagsRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog != nil {
		edges = append(edges, tagsrelation.EdgeBlog)
	}
	if m.tag != nil {
		edges = append(edges, tagsrelation.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagsRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tagsrelation.EdgeBlog:
		if id := m.blog; id != nil {
			return []ent.Value{*id}
		}
	case tagsrelation.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagsRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagsRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagsRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog {
		edges = append(edges, tagsrelation.EdgeBlog)
	}
	if m.clearedtag {
		edges = append(edges, tagsrelation.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagsRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case tagsrelation.EdgeBlog:
		return m.clearedblog
	case tagsrelation.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagsRelationMutation) ClearEdge(name string) error {
	switch name {
	case tagsrelation.EdgeBlog:
		m.ClearBlog()
		return nil
	case tagsrelation.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown TagsRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagsRelationMutation) ResetEdge(name string) error {
	switch name {
	case tagsrelation.EdgeBlog:
		m.ResetBlog()
		return nil
	case tagsrelation.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown TagsRelation edge %s", name)
}

// TravelExtendsMutation represents an operation that mutates the TravelExtends nodes in the graph.
type TravelExtendsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	account_id     *int
	addaccount_id  *int
	is_thumb       *bool
	is_collect     *bool
	clearedFields  map[string]struct{}
	extends        *int
	clearedextends bool
	done           bool
	oldValue       func(context.Context) (*TravelExtends, error)
	predicates     []predicate.TravelExtends
}

var _ ent.Mutation = (*TravelExtendsMutation)(nil)

// travelextendsOption allows management of the mutation configuration using functional options.
type travelextendsOption func(*TravelExtendsMutation)

// newTravelExtendsMutation creates new mutation for the TravelExtends entity.
func newTravelExtendsMutation(c config, op Op, opts ...travelextendsOption) *TravelExtendsMutation {
	m := &TravelExtendsMutation{
		config:        c,
		op:            op,
		typ:           TypeTravelExtends,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelExtendsID sets the ID field of the mutation.
func withTravelExtendsID(id int) travelextendsOption {
	return func(m *TravelExtendsMutation) {
		var (
			err   error
			once  sync.Once
			value *TravelExtends
		)
		m.oldValue = func(ctx context.Context) (*TravelExtends, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TravelExtends.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravelExtends sets the old TravelExtends of the mutation.
func withTravelExtends(node *TravelExtends) travelextendsOption {
	return func(m *TravelExtendsMutation) {
		m.oldValue = func(context.Context) (*TravelExtends, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelExtendsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelExtendsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelExtendsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelExtendsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TravelExtends.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelExtendsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelExtendsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelExtendsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelExtendsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelExtendsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelExtendsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelExtendsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelExtendsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelExtendsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelExtendsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelExtendsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelExtendsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelExtendsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelExtendsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelExtendsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelExtendsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelExtendsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelExtendsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelExtendsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelExtendsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelExtendsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelExtendsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelExtendsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelExtendsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelExtendsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelExtendsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelExtendsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelExtendsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelExtendsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelExtendsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *TravelExtendsMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TravelExtendsMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *TravelExtendsMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *TravelExtendsMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TravelExtendsMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTravelID sets the "travel_id" field.
func (m *TravelExtendsMutation) SetTravelID(i int) {
	m.extends = &i
}

// TravelID returns the value of the "travel_id" field in the mutation.
func (m *TravelExtendsMutation) TravelID() (r int, exists bool) {
	v := m.extends
	if v == nil {
		return
	}
	return *v, true
}

// OldTravelID returns the old "travel_id" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldTravelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTravelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTravelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTravelID: %w", err)
	}
	return oldValue.TravelID, nil
}

// ClearTravelID clears the value of the "travel_id" field.
func (m *TravelExtendsMutation) ClearTravelID() {
	m.extends = nil
	m.clearedFields[travelextends.FieldTravelID] = struct{}{}
}

// TravelIDCleared returns if the "travel_id" field was cleared in this mutation.
func (m *TravelExtendsMutation) TravelIDCleared() bool {
	_, ok := m.clearedFields[travelextends.FieldTravelID]
	return ok
}

// ResetTravelID resets all changes to the "travel_id" field.
func (m *TravelExtendsMutation) ResetTravelID() {
	m.extends = nil
	delete(m.clearedFields, travelextends.FieldTravelID)
}

// SetIsThumb sets the "is_thumb" field.
func (m *TravelExtendsMutation) SetIsThumb(b bool) {
	m.is_thumb = &b
}

// IsThumb returns the value of the "is_thumb" field in the mutation.
func (m *TravelExtendsMutation) IsThumb() (r bool, exists bool) {
	v := m.is_thumb
	if v == nil {
		return
	}
	return *v, true
}

// OldIsThumb returns the old "is_thumb" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldIsThumb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsThumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsThumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsThumb: %w", err)
	}
	return oldValue.IsThumb, nil
}

// ResetIsThumb resets all changes to the "is_thumb" field.
func (m *TravelExtendsMutation) ResetIsThumb() {
	m.is_thumb = nil
}

// SetIsCollect sets the "is_collect" field.
func (m *TravelExtendsMutation) SetIsCollect(b bool) {
	m.is_collect = &b
}

// IsCollect returns the value of the "is_collect" field in the mutation.
func (m *TravelExtendsMutation) IsCollect() (r bool, exists bool) {
	v := m.is_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCollect returns the old "is_collect" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldIsCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCollect: %w", err)
	}
	return oldValue.IsCollect, nil
}

// ResetIsCollect resets all changes to the "is_collect" field.
func (m *TravelExtendsMutation) ResetIsCollect() {
	m.is_collect = nil
}

// SetExtendsID sets the "extends" edge to the Travels entity by id.
func (m *TravelExtendsMutation) SetExtendsID(id int) {
	m.extends = &id
}

// ClearExtends clears the "extends" edge to the Travels entity.
func (m *TravelExtendsMutation) ClearExtends() {
	m.clearedextends = true
	m.clearedFields[travelextends.FieldTravelID] = struct{}{}
}

// ExtendsCleared reports if the "extends" edge to the Travels entity was cleared.
func (m *TravelExtendsMutation) ExtendsCleared() bool {
	return m.TravelIDCleared() || m.clearedextends
}

// ExtendsID returns the "extends" edge ID in the mutation.
func (m *TravelExtendsMutation) ExtendsID() (id int, exists bool) {
	if m.extends != nil {
		return *m.extends, true
	}
	return
}

// ExtendsIDs returns the "extends" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtendsID instead. It exists only for internal usage by the builders.
func (m *TravelExtendsMutation) ExtendsIDs() (ids []int) {
	if id := m.extends; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtends resets all changes to the "extends" edge.
func (m *TravelExtendsMutation) ResetExtends() {
	m.extends = nil
	m.clearedextends = false
}

// Where appends a list predicates to the TravelExtendsMutation builder.
func (m *TravelExtendsMutation) Where(ps ...predicate.TravelExtends) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelExtendsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelExtendsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TravelExtends, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelExtendsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelExtendsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TravelExtends).
func (m *TravelExtendsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelExtendsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, travelextends.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travelextends.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travelextends.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travelextends.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travelextends.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travelextends.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, travelextends.FieldAccountID)
	}
	if m.extends != nil {
		fields = append(fields, travelextends.FieldTravelID)
	}
	if m.is_thumb != nil {
		fields = append(fields, travelextends.FieldIsThumb)
	}
	if m.is_collect != nil {
		fields = append(fields, travelextends.FieldIsCollect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelExtendsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.CreatedAt()
	case travelextends.FieldCreatedBy:
		return m.CreatedBy()
	case travelextends.FieldUpdatedAt:
		return m.UpdatedAt()
	case travelextends.FieldUpdatedBy:
		return m.UpdatedBy()
	case travelextends.FieldDeletedAt:
		return m.DeletedAt()
	case travelextends.FieldDeletedBy:
		return m.DeletedBy()
	case travelextends.FieldAccountID:
		return m.AccountID()
	case travelextends.FieldTravelID:
		return m.TravelID()
	case travelextends.FieldIsThumb:
		return m.IsThumb()
	case travelextends.FieldIsCollect:
		return m.IsCollect()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelExtendsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travelextends.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travelextends.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travelextends.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travelextends.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travelextends.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travelextends.FieldAccountID:
		return m.OldAccountID(ctx)
	case travelextends.FieldTravelID:
		return m.OldTravelID(ctx)
	case travelextends.FieldIsThumb:
		return m.OldIsThumb(ctx)
	case travelextends.FieldIsCollect:
		return m.OldIsCollect(ctx)
	}
	return nil, fmt.Errorf("unknown TravelExtends field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travelextends.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travelextends.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travelextends.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travelextends.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travelextends.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travelextends.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travelextends.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case travelextends.FieldTravelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTravelID(v)
		return nil
	case travelextends.FieldIsThumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsThumb(v)
		return nil
	case travelextends.FieldIsCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCollect(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtends field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelExtendsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travelextends.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travelextends.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travelextends.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travelextends.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travelextends.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travelextends.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, travelextends.FieldAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelExtendsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travelextends.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travelextends.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travelextends.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travelextends.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travelextends.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travelextends.FieldAccountID:
		return m.AddedAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travelextends.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travelextends.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travelextends.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travelextends.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travelextends.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travelextends.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travelextends.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtends numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelExtendsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(travelextends.FieldTravelID) {
		fields = append(fields, travelextends.FieldTravelID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelExtendsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelExtendsMutation) ClearField(name string) error {
	switch name {
	case travelextends.FieldTravelID:
		m.ClearTravelID()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelExtendsMutation) ResetField(name string) error {
	switch name {
	case travelextends.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travelextends.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travelextends.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travelextends.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travelextends.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travelextends.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travelextends.FieldAccountID:
		m.ResetAccountID()
		return nil
	case travelextends.FieldTravelID:
		m.ResetTravelID()
		return nil
	case travelextends.FieldIsThumb:
		m.ResetIsThumb()
		return nil
	case travelextends.FieldIsCollect:
		m.ResetIsCollect()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelExtendsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extends != nil {
		edges = append(edges, travelextends.EdgeExtends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelExtendsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case travelextends.EdgeExtends:
		if id := m.extends; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelExtendsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelExtendsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelExtendsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextends {
		edges = append(edges, travelextends.EdgeExtends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelExtendsMutation) EdgeCleared(name string) bool {
	switch name {
	case travelextends.EdgeExtends:
		return m.clearedextends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelExtendsMutation) ClearEdge(name string) error {
	switch name {
	case travelextends.EdgeExtends:
		m.ClearExtends()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelExtendsMutation) ResetEdge(name string) error {
	switch name {
	case travelextends.EdgeExtends:
		m.ResetExtends()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends edge %s", name)
}

// TravelsMutation represents an operation that mutates the Travels nodes in the graph.
type TravelsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *int64
	addcreated_at         *int64
	created_by            *int64
	addcreated_by         *int64
	updated_at            *int64
	addupdated_at         *int64
	updated_by            *int64
	addupdated_by         *int64
	deleted_at            *int64
	adddeleted_at         *int64
	deleted_by            *int64
	adddeleted_by         *int64
	title                 *string
	description           *string
	video                 *string
	is_hidden             *bool
	photos                *[]string
	appendphotos          []string
	browse_num            *int
	addbrowse_num         *int
	thumb_num             *int
	addthumb_num          *int
	collect_num           *int
	addcollect_num        *int
	clearedFields         map[string]struct{}
	travel_extends        map[int]struct{}
	removedtravel_extends map[int]struct{}
	clearedtravel_extends bool
	travel_account        *int
	clearedtravel_account bool
	done                  bool
	oldValue              func(context.Context) (*Travels, error)
	predicates            []predicate.Travels
}

var _ ent.Mutation = (*TravelsMutation)(nil)

// travelsOption allows management of the mutation configuration using functional options.
type travelsOption func(*TravelsMutation)

// newTravelsMutation creates new mutation for the Travels entity.
func newTravelsMutation(c config, op Op, opts ...travelsOption) *TravelsMutation {
	m := &TravelsMutation{
		config:        c,
		op:            op,
		typ:           TypeTravels,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelsID sets the ID field of the mutation.
func withTravelsID(id int) travelsOption {
	return func(m *TravelsMutation) {
		var (
			err   error
			once  sync.Once
			value *Travels
		)
		m.oldValue = func(ctx context.Context) (*Travels, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Travels.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravels sets the old Travels of the mutation.
func withTravels(node *Travels) travelsOption {
	return func(m *TravelsMutation) {
		m.oldValue = func(context.Context) (*Travels, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Travels entities.
func (m *TravelsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Travels.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetTitle sets the "title" field.
func (m *TravelsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TravelsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TravelsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TravelsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TravelsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TravelsMutation) ResetDescription() {
	m.description = nil
}

// SetVideo sets the "video" field.
func (m *TravelsMutation) SetVideo(s string) {
	m.video = &s
}

// Video returns the value of the "video" field in the mutation.
func (m *TravelsMutation) Video() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideo returns the old "video" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldVideo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideo: %w", err)
	}
	return oldValue.Video, nil
}

// ResetVideo resets all changes to the "video" field.
func (m *TravelsMutation) ResetVideo() {
	m.video = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *TravelsMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *TravelsMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *TravelsMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetAccountID sets the "account_id" field.
func (m *TravelsMutation) SetAccountID(i int) {
	m.travel_account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TravelsMutation) AccountID() (r int, exists bool) {
	v := m.travel_account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *TravelsMutation) ClearAccountID() {
	m.travel_account = nil
	m.clearedFields[travels.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *TravelsMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[travels.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TravelsMutation) ResetAccountID() {
	m.travel_account = nil
	delete(m.clearedFields, travels.FieldAccountID)
}

// SetPhotos sets the "photos" field.
func (m *TravelsMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *TravelsMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *TravelsMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *TravelsMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *TravelsMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// SetBrowseNum sets the "browse_num" field.
func (m *TravelsMutation) SetBrowseNum(i int) {
	m.browse_num = &i
	m.addbrowse_num = nil
}

// BrowseNum returns the value of the "browse_num" field in the mutation.
func (m *TravelsMutation) BrowseNum() (r int, exists bool) {
	v := m.browse_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseNum returns the old "browse_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldBrowseNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseNum: %w", err)
	}
	return oldValue.BrowseNum, nil
}

// AddBrowseNum adds i to the "browse_num" field.
func (m *TravelsMutation) AddBrowseNum(i int) {
	if m.addbrowse_num != nil {
		*m.addbrowse_num += i
	} else {
		m.addbrowse_num = &i
	}
}

// AddedBrowseNum returns the value that was added to the "browse_num" field in this mutation.
func (m *TravelsMutation) AddedBrowseNum() (r int, exists bool) {
	v := m.addbrowse_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseNum resets all changes to the "browse_num" field.
func (m *TravelsMutation) ResetBrowseNum() {
	m.browse_num = nil
	m.addbrowse_num = nil
}

// SetThumbNum sets the "thumb_num" field.
func (m *TravelsMutation) SetThumbNum(i int) {
	m.thumb_num = &i
	m.addthumb_num = nil
}

// ThumbNum returns the value of the "thumb_num" field in the mutation.
func (m *TravelsMutation) ThumbNum() (r int, exists bool) {
	v := m.thumb_num
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbNum returns the old "thumb_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldThumbNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbNum: %w", err)
	}
	return oldValue.ThumbNum, nil
}

// AddThumbNum adds i to the "thumb_num" field.
func (m *TravelsMutation) AddThumbNum(i int) {
	if m.addthumb_num != nil {
		*m.addthumb_num += i
	} else {
		m.addthumb_num = &i
	}
}

// AddedThumbNum returns the value that was added to the "thumb_num" field in this mutation.
func (m *TravelsMutation) AddedThumbNum() (r int, exists bool) {
	v := m.addthumb_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetThumbNum resets all changes to the "thumb_num" field.
func (m *TravelsMutation) ResetThumbNum() {
	m.thumb_num = nil
	m.addthumb_num = nil
}

// SetCollectNum sets the "collect_num" field.
func (m *TravelsMutation) SetCollectNum(i int) {
	m.collect_num = &i
	m.addcollect_num = nil
}

// CollectNum returns the value of the "collect_num" field in the mutation.
func (m *TravelsMutation) CollectNum() (r int, exists bool) {
	v := m.collect_num
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectNum returns the old "collect_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCollectNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectNum: %w", err)
	}
	return oldValue.CollectNum, nil
}

// AddCollectNum adds i to the "collect_num" field.
func (m *TravelsMutation) AddCollectNum(i int) {
	if m.addcollect_num != nil {
		*m.addcollect_num += i
	} else {
		m.addcollect_num = &i
	}
}

// AddedCollectNum returns the value that was added to the "collect_num" field in this mutation.
func (m *TravelsMutation) AddedCollectNum() (r int, exists bool) {
	v := m.addcollect_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectNum resets all changes to the "collect_num" field.
func (m *TravelsMutation) ResetCollectNum() {
	m.collect_num = nil
	m.addcollect_num = nil
}

// AddTravelExtendIDs adds the "travel_extends" edge to the TravelExtends entity by ids.
func (m *TravelsMutation) AddTravelExtendIDs(ids ...int) {
	if m.travel_extends == nil {
		m.travel_extends = make(map[int]struct{})
	}
	for i := range ids {
		m.travel_extends[ids[i]] = struct{}{}
	}
}

// ClearTravelExtends clears the "travel_extends" edge to the TravelExtends entity.
func (m *TravelsMutation) ClearTravelExtends() {
	m.clearedtravel_extends = true
}

// TravelExtendsCleared reports if the "travel_extends" edge to the TravelExtends entity was cleared.
func (m *TravelsMutation) TravelExtendsCleared() bool {
	return m.clearedtravel_extends
}

// RemoveTravelExtendIDs removes the "travel_extends" edge to the TravelExtends entity by IDs.
func (m *TravelsMutation) RemoveTravelExtendIDs(ids ...int) {
	if m.removedtravel_extends == nil {
		m.removedtravel_extends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.travel_extends, ids[i])
		m.removedtravel_extends[ids[i]] = struct{}{}
	}
}

// RemovedTravelExtends returns the removed IDs of the "travel_extends" edge to the TravelExtends entity.
func (m *TravelsMutation) RemovedTravelExtendsIDs() (ids []int) {
	for id := range m.removedtravel_extends {
		ids = append(ids, id)
	}
	return
}

// TravelExtendsIDs returns the "travel_extends" edge IDs in the mutation.
func (m *TravelsMutation) TravelExtendsIDs() (ids []int) {
	for id := range m.travel_extends {
		ids = append(ids, id)
	}
	return
}

// ResetTravelExtends resets all changes to the "travel_extends" edge.
func (m *TravelsMutation) ResetTravelExtends() {
	m.travel_extends = nil
	m.clearedtravel_extends = false
	m.removedtravel_extends = nil
}

// SetTravelAccountID sets the "travel_account" edge to the Account entity by id.
func (m *TravelsMutation) SetTravelAccountID(id int) {
	m.travel_account = &id
}

// ClearTravelAccount clears the "travel_account" edge to the Account entity.
func (m *TravelsMutation) ClearTravelAccount() {
	m.clearedtravel_account = true
	m.clearedFields[travels.FieldAccountID] = struct{}{}
}

// TravelAccountCleared reports if the "travel_account" edge to the Account entity was cleared.
func (m *TravelsMutation) TravelAccountCleared() bool {
	return m.AccountIDCleared() || m.clearedtravel_account
}

// TravelAccountID returns the "travel_account" edge ID in the mutation.
func (m *TravelsMutation) TravelAccountID() (id int, exists bool) {
	if m.travel_account != nil {
		return *m.travel_account, true
	}
	return
}

// TravelAccountIDs returns the "travel_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TravelAccountID instead. It exists only for internal usage by the builders.
func (m *TravelsMutation) TravelAccountIDs() (ids []int) {
	if id := m.travel_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTravelAccount resets all changes to the "travel_account" edge.
func (m *TravelsMutation) ResetTravelAccount() {
	m.travel_account = nil
	m.clearedtravel_account = false
}

// Where appends a list predicates to the TravelsMutation builder.
func (m *TravelsMutation) Where(ps ...predicate.Travels) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Travels, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Travels).
func (m *TravelsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, travels.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travels.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travels.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travels.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travels.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travels.FieldDeletedBy)
	}
	if m.title != nil {
		fields = append(fields, travels.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, travels.FieldDescription)
	}
	if m.video != nil {
		fields = append(fields, travels.FieldVideo)
	}
	if m.is_hidden != nil {
		fields = append(fields, travels.FieldIsHidden)
	}
	if m.travel_account != nil {
		fields = append(fields, travels.FieldAccountID)
	}
	if m.photos != nil {
		fields = append(fields, travels.FieldPhotos)
	}
	if m.browse_num != nil {
		fields = append(fields, travels.FieldBrowseNum)
	}
	if m.thumb_num != nil {
		fields = append(fields, travels.FieldThumbNum)
	}
	if m.collect_num != nil {
		fields = append(fields, travels.FieldCollectNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travels.FieldCreatedAt:
		return m.CreatedAt()
	case travels.FieldCreatedBy:
		return m.CreatedBy()
	case travels.FieldUpdatedAt:
		return m.UpdatedAt()
	case travels.FieldUpdatedBy:
		return m.UpdatedBy()
	case travels.FieldDeletedAt:
		return m.DeletedAt()
	case travels.FieldDeletedBy:
		return m.DeletedBy()
	case travels.FieldTitle:
		return m.Title()
	case travels.FieldDescription:
		return m.Description()
	case travels.FieldVideo:
		return m.Video()
	case travels.FieldIsHidden:
		return m.IsHidden()
	case travels.FieldAccountID:
		return m.AccountID()
	case travels.FieldPhotos:
		return m.Photos()
	case travels.FieldBrowseNum:
		return m.BrowseNum()
	case travels.FieldThumbNum:
		return m.ThumbNum()
	case travels.FieldCollectNum:
		return m.CollectNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travels.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travels.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travels.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travels.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travels.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travels.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travels.FieldTitle:
		return m.OldTitle(ctx)
	case travels.FieldDescription:
		return m.OldDescription(ctx)
	case travels.FieldVideo:
		return m.OldVideo(ctx)
	case travels.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case travels.FieldAccountID:
		return m.OldAccountID(ctx)
	case travels.FieldPhotos:
		return m.OldPhotos(ctx)
	case travels.FieldBrowseNum:
		return m.OldBrowseNum(ctx)
	case travels.FieldThumbNum:
		return m.OldThumbNum(ctx)
	case travels.FieldCollectNum:
		return m.OldCollectNum(ctx)
	}
	return nil, fmt.Errorf("unknown Travels field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travels.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travels.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travels.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travels.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travels.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travels.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travels.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case travels.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case travels.FieldVideo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideo(v)
		return nil
	case travels.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case travels.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case travels.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	case travels.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseNum(v)
		return nil
	case travels.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbNum(v)
		return nil
	case travels.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travels field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travels.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travels.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travels.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travels.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travels.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travels.FieldDeletedBy)
	}
	if m.addbrowse_num != nil {
		fields = append(fields, travels.FieldBrowseNum)
	}
	if m.addthumb_num != nil {
		fields = append(fields, travels.FieldThumbNum)
	}
	if m.addcollect_num != nil {
		fields = append(fields, travels.FieldCollectNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travels.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travels.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travels.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travels.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travels.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travels.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travels.FieldBrowseNum:
		return m.AddedBrowseNum()
	case travels.FieldThumbNum:
		return m.AddedThumbNum()
	case travels.FieldCollectNum:
		return m.AddedCollectNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travels.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travels.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travels.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travels.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travels.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travels.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travels.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseNum(v)
		return nil
	case travels.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbNum(v)
		return nil
	case travels.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travels numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(travels.FieldAccountID) {
		fields = append(fields, travels.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelsMutation) ClearField(name string) error {
	switch name {
	case travels.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown Travels nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelsMutation) ResetField(name string) error {
	switch name {
	case travels.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travels.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travels.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travels.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travels.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travels.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travels.FieldTitle:
		m.ResetTitle()
		return nil
	case travels.FieldDescription:
		m.ResetDescription()
		return nil
	case travels.FieldVideo:
		m.ResetVideo()
		return nil
	case travels.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case travels.FieldAccountID:
		m.ResetAccountID()
		return nil
	case travels.FieldPhotos:
		m.ResetPhotos()
		return nil
	case travels.FieldBrowseNum:
		m.ResetBrowseNum()
		return nil
	case travels.FieldThumbNum:
		m.ResetThumbNum()
		return nil
	case travels.FieldCollectNum:
		m.ResetCollectNum()
		return nil
	}
	return fmt.Errorf("unknown Travels field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.travel_extends != nil {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	if m.travel_account != nil {
		edges = append(edges, travels.EdgeTravelAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case travels.EdgeTravelExtends:
		ids := make([]ent.Value, 0, len(m.travel_extends))
		for id := range m.travel_extends {
			ids = append(ids, id)
		}
		return ids
	case travels.EdgeTravelAccount:
		if id := m.travel_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtravel_extends != nil {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case travels.EdgeTravelExtends:
		ids := make([]ent.Value, 0, len(m.removedtravel_extends))
		for id := range m.removedtravel_extends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtravel_extends {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	if m.clearedtravel_account {
		edges = append(edges, travels.EdgeTravelAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelsMutation) EdgeCleared(name string) bool {
	switch name {
	case travels.EdgeTravelExtends:
		return m.clearedtravel_extends
	case travels.EdgeTravelAccount:
		return m.clearedtravel_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelsMutation) ClearEdge(name string) error {
	switch name {
	case travels.EdgeTravelAccount:
		m.ClearTravelAccount()
		return nil
	}
	return fmt.Errorf("unknown Travels unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelsMutation) ResetEdge(name string) error {
	switch name {
	case travels.EdgeTravelExtends:
		m.ResetTravelExtends()
		return nil
	case travels.EdgeTravelAccount:
		m.ResetTravelAccount()
		return nil
	}
	return fmt.Errorf("unknown Travels edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	name          *string
	avatar        *string
	email         *string
	professional  *string
	address       *string
	skills        *[]string
	appendskills  []string
	description   *string
	experience    *int
	addexperience *int
	project       *int
	addproject    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetProfessional sets the "professional" field.
func (m *UserMutation) SetProfessional(s string) {
	m.professional = &s
}

// Professional returns the value of the "professional" field in the mutation.
func (m *UserMutation) Professional() (r string, exists bool) {
	v := m.professional
	if v == nil {
		return
	}
	return *v, true
}

// OldProfessional returns the old "professional" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfessional(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfessional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfessional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfessional: %w", err)
	}
	return oldValue.Professional, nil
}

// ResetProfessional resets all changes to the "professional" field.
func (m *UserMutation) ResetProfessional() {
	m.professional = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetSkills sets the "skills" field.
func (m *UserMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
}

// SetExperience sets the "experience" field.
func (m *UserMutation) SetExperience(i int) {
	m.experience = &i
	m.addexperience = nil
}

// Experience returns the value of the "experience" field in the mutation.
func (m *UserMutation) Experience() (r int, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperience returns the old "experience" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExperience(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperience: %w", err)
	}
	return oldValue.Experience, nil
}

// AddExperience adds i to the "experience" field.
func (m *UserMutation) AddExperience(i int) {
	if m.addexperience != nil {
		*m.addexperience += i
	} else {
		m.addexperience = &i
	}
}

// AddedExperience returns the value that was added to the "experience" field in this mutation.
func (m *UserMutation) AddedExperience() (r int, exists bool) {
	v := m.addexperience
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperience resets all changes to the "experience" field.
func (m *UserMutation) ResetExperience() {
	m.experience = nil
	m.addexperience = nil
}

// SetProject sets the "project" field.
func (m *UserMutation) SetProject(i int) {
	m.project = &i
	m.addproject = nil
}

// Project returns the value of the "project" field in the mutation.
func (m *UserMutation) Project() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProject returns the old "project" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProject: %w", err)
	}
	return oldValue.Project, nil
}

// AddProject adds i to the "project" field.
func (m *UserMutation) AddProject(i int) {
	if m.addproject != nil {
		*m.addproject += i
	} else {
		m.addproject = &i
	}
}

// AddedProject returns the value that was added to the "project" field in this mutation.
func (m *UserMutation) AddedProject() (r int, exists bool) {
	v := m.addproject
	if v == nil {
		return
	}
	return *v, true
}

// ResetProject resets all changes to the "project" field.
func (m *UserMutation) ResetProject() {
	m.project = nil
	m.addproject = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.professional != nil {
		fields = append(fields, user.FieldProfessional)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.skills != nil {
		fields = append(fields, user.FieldSkills)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.experience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.project != nil {
		fields = append(fields, user.FieldProject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldName:
		return m.Name()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldEmail:
		return m.Email()
	case user.FieldProfessional:
		return m.Professional()
	case user.FieldAddress:
		return m.Address()
	case user.FieldSkills:
		return m.Skills()
	case user.FieldDescription:
		return m.Description()
	case user.FieldExperience:
		return m.Experience()
	case user.FieldProject:
		return m.Project()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldProfessional:
		return m.OldProfessional(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldSkills:
		return m.OldSkills(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldExperience:
		return m.OldExperience(ctx)
	case user.FieldProject:
		return m.OldProject(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldProfessional:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfessional(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperience(v)
		return nil
	case user.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProject(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.addexperience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.addproject != nil {
		fields = append(fields, user.FieldProject)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.AddedCreatedAt()
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	case user.FieldExperience:
		return m.AddedExperience()
	case user.FieldProject:
		return m.AddedProject()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperience(v)
		return nil
	case user.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProject(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldProfessional:
		m.ResetProfessional()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldSkills:
		m.ResetSkills()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldExperience:
		m.ResetExperience()
		return nil
	case user.FieldProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserExperienceMutation represents an operation that mutates the UserExperience nodes in the graph.
type UserExperienceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	company          *string
	role             *string
	location         *string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	description      *string
	responsibilities *string
	achievements     *string
	skills           *[]string
	appendskills     []string
	project          *int
	addproject       *int
	image            *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserExperience, error)
	predicates       []predicate.UserExperience
}

var _ ent.Mutation = (*UserExperienceMutation)(nil)

// userexperienceOption allows management of the mutation configuration using functional options.
type userexperienceOption func(*UserExperienceMutation)

// newUserExperienceMutation creates new mutation for the UserExperience entity.
func newUserExperienceMutation(c config, op Op, opts ...userexperienceOption) *UserExperienceMutation {
	m := &UserExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserExperienceID sets the ID field of the mutation.
func withUserExperienceID(id int) userexperienceOption {
	return func(m *UserExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserExperience
		)
		m.oldValue = func(ctx context.Context) (*UserExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserExperience sets the old UserExperience of the mutation.
func withUserExperience(node *UserExperience) userexperienceOption {
	return func(m *UserExperienceMutation) {
		m.oldValue = func(context.Context) (*UserExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserExperience entities.
func (m *UserExperienceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserExperienceMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserExperienceMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserExperienceMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserExperienceMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserExperienceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserExperienceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserExperienceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserExperienceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserExperienceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserExperienceMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserExperienceMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserExperienceMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserExperienceMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserExperienceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserExperienceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserExperienceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserExperienceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserExperienceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserExperienceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserExperienceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserExperienceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserExperienceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserExperienceMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserExperienceMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserExperienceMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserExperienceMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserExperienceMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *UserExperienceMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserExperienceMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserExperienceMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserExperienceMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserExperienceMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCompany sets the "company" field.
func (m *UserExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *UserExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetRole sets the "role" field.
func (m *UserExperienceMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserExperienceMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserExperienceMutation) ResetRole() {
	m.role = nil
}

// SetLocation sets the "location" field.
func (m *UserExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *UserExperienceMutation) ResetLocation() {
	m.location = nil
}

// SetStart sets the "start" field.
func (m *UserExperienceMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *UserExperienceMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *UserExperienceMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *UserExperienceMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *UserExperienceMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *UserExperienceMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *UserExperienceMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *UserExperienceMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *UserExperienceMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *UserExperienceMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetDescription sets the "description" field.
func (m *UserExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserExperienceMutation) ResetDescription() {
	m.description = nil
}

// SetResponsibilities sets the "responsibilities" field.
func (m *UserExperienceMutation) SetResponsibilities(s string) {
	m.responsibilities = &s
}

// Responsibilities returns the value of the "responsibilities" field in the mutation.
func (m *UserExperienceMutation) Responsibilities() (r string, exists bool) {
	v := m.responsibilities
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibilities returns the old "responsibilities" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldResponsibilities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibilities: %w", err)
	}
	return oldValue.Responsibilities, nil
}

// ResetResponsibilities resets all changes to the "responsibilities" field.
func (m *UserExperienceMutation) ResetResponsibilities() {
	m.responsibilities = nil
}

// SetAchievements sets the "achievements" field.
func (m *UserExperienceMutation) SetAchievements(s string) {
	m.achievements = &s
}

// Achievements returns the value of the "achievements" field in the mutation.
func (m *UserExperienceMutation) Achievements() (r string, exists bool) {
	v := m.achievements
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievements returns the old "achievements" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldAchievements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievements: %w", err)
	}
	return oldValue.Achievements, nil
}

// ResetAchievements resets all changes to the "achievements" field.
func (m *UserExperienceMutation) ResetAchievements() {
	m.achievements = nil
}

// SetSkills sets the "skills" field.
func (m *UserExperienceMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserExperienceMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserExperienceMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserExperienceMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserExperienceMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetProject sets the "project" field.
func (m *UserExperienceMutation) SetProject(i int) {
	m.project = &i
	m.addproject = nil
}

// Project returns the value of the "project" field in the mutation.
func (m *UserExperienceMutation) Project() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProject returns the old "project" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldProject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProject: %w", err)
	}
	return oldValue.Project, nil
}

// AddProject adds i to the "project" field.
func (m *UserExperienceMutation) AddProject(i int) {
	if m.addproject != nil {
		*m.addproject += i
	} else {
		m.addproject = &i
	}
}

// AddedProject returns the value that was added to the "project" field in this mutation.
func (m *UserExperienceMutation) AddedProject() (r int, exists bool) {
	v := m.addproject
	if v == nil {
		return
	}
	return *v, true
}

// ResetProject resets all changes to the "project" field.
func (m *UserExperienceMutation) ResetProject() {
	m.project = nil
	m.addproject = nil
}

// SetImage sets the "image" field.
func (m *UserExperienceMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *UserExperienceMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *UserExperienceMutation) ResetImage() {
	m.image = nil
}

// Where appends a list predicates to the UserExperienceMutation builder.
func (m *UserExperienceMutation) Where(ps ...predicate.UserExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserExperience).
func (m *UserExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserExperienceMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, userexperience.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userexperience.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userexperience.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userexperience.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userexperience.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userexperience.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, userexperience.FieldUserID)
	}
	if m.company != nil {
		fields = append(fields, userexperience.FieldCompany)
	}
	if m.role != nil {
		fields = append(fields, userexperience.FieldRole)
	}
	if m.location != nil {
		fields = append(fields, userexperience.FieldLocation)
	}
	if m.start != nil {
		fields = append(fields, userexperience.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, userexperience.FieldEnd)
	}
	if m.description != nil {
		fields = append(fields, userexperience.FieldDescription)
	}
	if m.responsibilities != nil {
		fields = append(fields, userexperience.FieldResponsibilities)
	}
	if m.achievements != nil {
		fields = append(fields, userexperience.FieldAchievements)
	}
	if m.skills != nil {
		fields = append(fields, userexperience.FieldSkills)
	}
	if m.project != nil {
		fields = append(fields, userexperience.FieldProject)
	}
	if m.image != nil {
		fields = append(fields, userexperience.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.CreatedAt()
	case userexperience.FieldCreatedBy:
		return m.CreatedBy()
	case userexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	case userexperience.FieldUpdatedBy:
		return m.UpdatedBy()
	case userexperience.FieldDeletedAt:
		return m.DeletedAt()
	case userexperience.FieldDeletedBy:
		return m.DeletedBy()
	case userexperience.FieldUserID:
		return m.UserID()
	case userexperience.FieldCompany:
		return m.Company()
	case userexperience.FieldRole:
		return m.Role()
	case userexperience.FieldLocation:
		return m.Location()
	case userexperience.FieldStart:
		return m.Start()
	case userexperience.FieldEnd:
		return m.End()
	case userexperience.FieldDescription:
		return m.Description()
	case userexperience.FieldResponsibilities:
		return m.Responsibilities()
	case userexperience.FieldAchievements:
		return m.Achievements()
	case userexperience.FieldSkills:
		return m.Skills()
	case userexperience.FieldProject:
		return m.Project()
	case userexperience.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userexperience.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userexperience.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userexperience.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userexperience.FieldUserID:
		return m.OldUserID(ctx)
	case userexperience.FieldCompany:
		return m.OldCompany(ctx)
	case userexperience.FieldRole:
		return m.OldRole(ctx)
	case userexperience.FieldLocation:
		return m.OldLocation(ctx)
	case userexperience.FieldStart:
		return m.OldStart(ctx)
	case userexperience.FieldEnd:
		return m.OldEnd(ctx)
	case userexperience.FieldDescription:
		return m.OldDescription(ctx)
	case userexperience.FieldResponsibilities:
		return m.OldResponsibilities(ctx)
	case userexperience.FieldAchievements:
		return m.OldAchievements(ctx)
	case userexperience.FieldSkills:
		return m.OldSkills(ctx)
	case userexperience.FieldProject:
		return m.OldProject(ctx)
	case userexperience.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown UserExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case userexperience.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case userexperience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case userexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case userexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case userexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userexperience.FieldResponsibilities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibilities(v)
		return nil
	case userexperience.FieldAchievements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievements(v)
		return nil
	case userexperience.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case userexperience.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProject(v)
		return nil
	case userexperience.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown UserExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userexperience.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, userexperience.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userexperience.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userexperience.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userexperience.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userexperience.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, userexperience.FieldUserID)
	}
	if m.addstart != nil {
		fields = append(fields, userexperience.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, userexperience.FieldEnd)
	}
	if m.addproject != nil {
		fields = append(fields, userexperience.FieldProject)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userexperience.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userexperience.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userexperience.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userexperience.FieldDeletedAt:
		return m.AddedDeletedAt()
	case userexperience.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userexperience.FieldUserID:
		return m.AddedUserID()
	case userexperience.FieldStart:
		return m.AddedStart()
	case userexperience.FieldEnd:
		return m.AddedEnd()
	case userexperience.FieldProject:
		return m.AddedProject()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case userexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case userexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case userexperience.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProject(v)
		return nil
	}
	return fmt.Errorf("unknown UserExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserExperienceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserExperienceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserExperienceMutation) ResetField(name string) error {
	switch name {
	case userexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userexperience.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userexperience.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userexperience.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userexperience.FieldUserID:
		m.ResetUserID()
		return nil
	case userexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case userexperience.FieldRole:
		m.ResetRole()
		return nil
	case userexperience.FieldLocation:
		m.ResetLocation()
		return nil
	case userexperience.FieldStart:
		m.ResetStart()
		return nil
	case userexperience.FieldEnd:
		m.ResetEnd()
		return nil
	case userexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case userexperience.FieldResponsibilities:
		m.ResetResponsibilities()
		return nil
	case userexperience.FieldAchievements:
		m.ResetAchievements()
		return nil
	case userexperience.FieldSkills:
		m.ResetSkills()
		return nil
	case userexperience.FieldProject:
		m.ResetProject()
		return nil
	case userexperience.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown UserExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserExperienceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserExperienceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserExperienceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserExperienceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserExperience edge %s", name)
}

// UserFamousQuotesMutation represents an operation that mutates the UserFamousQuotes nodes in the graph.
type UserFamousQuotesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	text          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserFamousQuotes, error)
	predicates    []predicate.UserFamousQuotes
}

var _ ent.Mutation = (*UserFamousQuotesMutation)(nil)

// userfamousquotesOption allows management of the mutation configuration using functional options.
type userfamousquotesOption func(*UserFamousQuotesMutation)

// newUserFamousQuotesMutation creates new mutation for the UserFamousQuotes entity.
func newUserFamousQuotesMutation(c config, op Op, opts ...userfamousquotesOption) *UserFamousQuotesMutation {
	m := &UserFamousQuotesMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFamousQuotes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFamousQuotesID sets the ID field of the mutation.
func withUserFamousQuotesID(id int) userfamousquotesOption {
	return func(m *UserFamousQuotesMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFamousQuotes
		)
		m.oldValue = func(ctx context.Context) (*UserFamousQuotes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFamousQuotes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFamousQuotes sets the old UserFamousQuotes of the mutation.
func withUserFamousQuotes(node *UserFamousQuotes) userfamousquotesOption {
	return func(m *UserFamousQuotesMutation) {
		m.oldValue = func(context.Context) (*UserFamousQuotes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFamousQuotesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFamousQuotesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFamousQuotes entities.
func (m *UserFamousQuotesMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFamousQuotesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFamousQuotesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFamousQuotes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFamousQuotesMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFamousQuotesMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserFamousQuotesMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserFamousQuotesMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFamousQuotesMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserFamousQuotesMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserFamousQuotesMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserFamousQuotesMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserFamousQuotesMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserFamousQuotesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserFamousQuotesMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserFamousQuotesMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserFamousQuotesMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserFamousQuotesMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserFamousQuotesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserFamousQuotesMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserFamousQuotesMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserFamousQuotesMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserFamousQuotesMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserFamousQuotesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserFamousQuotesMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserFamousQuotesMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserFamousQuotesMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserFamousQuotesMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserFamousQuotesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserFamousQuotesMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserFamousQuotesMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserFamousQuotesMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserFamousQuotesMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserFamousQuotesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetText sets the "text" field.
func (m *UserFamousQuotesMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *UserFamousQuotesMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the UserFamousQuotes entity.
// If the UserFamousQuotes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFamousQuotesMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *UserFamousQuotesMutation) ResetText() {
	m.text = nil
}

// Where appends a list predicates to the UserFamousQuotesMutation builder.
func (m *UserFamousQuotesMutation) Where(ps ...predicate.UserFamousQuotes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFamousQuotesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFamousQuotesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFamousQuotes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFamousQuotesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFamousQuotesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFamousQuotes).
func (m *UserFamousQuotesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFamousQuotesMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userfamousquotes.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userfamousquotes.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userfamousquotes.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userfamousquotes.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userfamousquotes.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userfamousquotes.FieldDeletedBy)
	}
	if m.text != nil {
		fields = append(fields, userfamousquotes.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFamousQuotesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		return m.CreatedAt()
	case userfamousquotes.FieldCreatedBy:
		return m.CreatedBy()
	case userfamousquotes.FieldUpdatedAt:
		return m.UpdatedAt()
	case userfamousquotes.FieldUpdatedBy:
		return m.UpdatedBy()
	case userfamousquotes.FieldDeletedAt:
		return m.DeletedAt()
	case userfamousquotes.FieldDeletedBy:
		return m.DeletedBy()
	case userfamousquotes.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFamousQuotesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfamousquotes.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userfamousquotes.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userfamousquotes.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userfamousquotes.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userfamousquotes.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userfamousquotes.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown UserFamousQuotes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFamousQuotesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfamousquotes.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userfamousquotes.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userfamousquotes.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userfamousquotes.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userfamousquotes.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userfamousquotes.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown UserFamousQuotes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFamousQuotesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userfamousquotes.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, userfamousquotes.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userfamousquotes.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userfamousquotes.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userfamousquotes.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userfamousquotes.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFamousQuotesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userfamousquotes.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userfamousquotes.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userfamousquotes.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userfamousquotes.FieldDeletedAt:
		return m.AddedDeletedAt()
	case userfamousquotes.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFamousQuotesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userfamousquotes.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userfamousquotes.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userfamousquotes.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userfamousquotes.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case userfamousquotes.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserFamousQuotes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFamousQuotesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFamousQuotesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFamousQuotesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFamousQuotes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFamousQuotesMutation) ResetField(name string) error {
	switch name {
	case userfamousquotes.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfamousquotes.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userfamousquotes.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userfamousquotes.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userfamousquotes.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userfamousquotes.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userfamousquotes.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown UserFamousQuotes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFamousQuotesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFamousQuotesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFamousQuotesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFamousQuotesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFamousQuotesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFamousQuotesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFamousQuotesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserFamousQuotes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFamousQuotesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserFamousQuotes edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	experience_id    *int
	addexperience_id *int
	title            *string
	description      *string
	skills           *[]string
	appendskills     []string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	link             *string
	photos           *[]string
	appendphotos     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserProject, error)
	predicates       []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id int) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProject entities.
func (m *UserProjectMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserProjectMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserProjectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserProjectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserProjectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserProjectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserProjectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserProjectMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserProjectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserProjectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserProjectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserProjectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserProjectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserProjectMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserProjectMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserProjectMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserProjectMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserProjectMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserProjectMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserProjectMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserProjectMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserProjectMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserProjectMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserProjectMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetExperienceID sets the "experience_id" field.
func (m *UserProjectMutation) SetExperienceID(i int) {
	m.experience_id = &i
	m.addexperience_id = nil
}

// ExperienceID returns the value of the "experience_id" field in the mutation.
func (m *UserProjectMutation) ExperienceID() (r int, exists bool) {
	v := m.experience_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceID returns the old "experience_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldExperienceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceID: %w", err)
	}
	return oldValue.ExperienceID, nil
}

// AddExperienceID adds i to the "experience_id" field.
func (m *UserProjectMutation) AddExperienceID(i int) {
	if m.addexperience_id != nil {
		*m.addexperience_id += i
	} else {
		m.addexperience_id = &i
	}
}

// AddedExperienceID returns the value that was added to the "experience_id" field in this mutation.
func (m *UserProjectMutation) AddedExperienceID() (r int, exists bool) {
	v := m.addexperience_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperienceID resets all changes to the "experience_id" field.
func (m *UserProjectMutation) ResetExperienceID() {
	m.experience_id = nil
	m.addexperience_id = nil
}

// SetTitle sets the "title" field.
func (m *UserProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UserProjectMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *UserProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserProjectMutation) ResetDescription() {
	m.description = nil
}

// SetSkills sets the "skills" field.
func (m *UserProjectMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserProjectMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserProjectMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserProjectMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserProjectMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetStart sets the "start" field.
func (m *UserProjectMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *UserProjectMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *UserProjectMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *UserProjectMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *UserProjectMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *UserProjectMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *UserProjectMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *UserProjectMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *UserProjectMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *UserProjectMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetLink sets the "link" field.
func (m *UserProjectMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *UserProjectMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *UserProjectMutation) ResetLink() {
	m.link = nil
}

// SetPhotos sets the "photos" field.
func (m *UserProjectMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *UserProjectMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *UserProjectMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *UserProjectMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *UserProjectMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userproject.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userproject.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userproject.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.experience_id != nil {
		fields = append(fields, userproject.FieldExperienceID)
	}
	if m.title != nil {
		fields = append(fields, userproject.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, userproject.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, userproject.FieldSkills)
	}
	if m.start != nil {
		fields = append(fields, userproject.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, userproject.FieldEnd)
	}
	if m.link != nil {
		fields = append(fields, userproject.FieldLink)
	}
	if m.photos != nil {
		fields = append(fields, userproject.FieldPhotos)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldCreatedBy:
		return m.CreatedBy()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case userproject.FieldUpdatedBy:
		return m.UpdatedBy()
	case userproject.FieldDeletedAt:
		return m.DeletedAt()
	case userproject.FieldDeletedBy:
		return m.DeletedBy()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldExperienceID:
		return m.ExperienceID()
	case userproject.FieldTitle:
		return m.Title()
	case userproject.FieldDescription:
		return m.Description()
	case userproject.FieldSkills:
		return m.Skills()
	case userproject.FieldStart:
		return m.Start()
	case userproject.FieldEnd:
		return m.End()
	case userproject.FieldLink:
		return m.Link()
	case userproject.FieldPhotos:
		return m.Photos()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userproject.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userproject.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldExperienceID:
		return m.OldExperienceID(ctx)
	case userproject.FieldTitle:
		return m.OldTitle(ctx)
	case userproject.FieldDescription:
		return m.OldDescription(ctx)
	case userproject.FieldSkills:
		return m.OldSkills(ctx)
	case userproject.FieldStart:
		return m.OldStart(ctx)
	case userproject.FieldEnd:
		return m.OldEnd(ctx)
	case userproject.FieldLink:
		return m.OldLink(ctx)
	case userproject.FieldPhotos:
		return m.OldPhotos(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceID(v)
		return nil
	case userproject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case userproject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userproject.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case userproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case userproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case userproject.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case userproject.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, userproject.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userproject.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userproject.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.addexperience_id != nil {
		fields = append(fields, userproject.FieldExperienceID)
	}
	if m.addstart != nil {
		fields = append(fields, userproject.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, userproject.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userproject.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userproject.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userproject.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userproject.FieldDeletedAt:
		return m.AddedDeletedAt()
	case userproject.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userproject.FieldUserID:
		return m.AddedUserID()
	case userproject.FieldExperienceID:
		return m.AddedExperienceID()
	case userproject.FieldStart:
		return m.AddedStart()
	case userproject.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case userproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperienceID(v)
		return nil
	case userproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case userproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userproject.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userproject.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldExperienceID:
		m.ResetExperienceID()
		return nil
	case userproject.FieldTitle:
		m.ResetTitle()
		return nil
	case userproject.FieldDescription:
		m.ResetDescription()
		return nil
	case userproject.FieldSkills:
		m.ResetSkills()
		return nil
	case userproject.FieldStart:
		m.ResetStart()
		return nil
	case userproject.FieldEnd:
		m.ResetEnd()
		return nil
	case userproject.FieldLink:
		m.ResetLink()
		return nil
	case userproject.FieldPhotos:
		m.ResetPhotos()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserProject edge %s", name)
}
