// Code generated by ent, DO NOT EDIT.

package ent

import (
	"blog/internal/ent/account"
	"blog/internal/ent/blogs"
	"blog/internal/ent/blogscomment"
	"blog/internal/ent/blogscontent"
	"blog/internal/ent/files"
	"blog/internal/ent/filesextend"
	"blog/internal/ent/predicate"
	"blog/internal/ent/travelextends"
	"blog/internal/ent/travels"
	"blog/internal/ent/user"
	"blog/internal/ent/userexperience"
	"blog/internal/ent/userproject"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount        = "Account"
	TypeBlogs          = "Blogs"
	TypeBlogsComment   = "BlogsComment"
	TypeBlogsContent   = "BlogsContent"
	TypeFiles          = "Files"
	TypeFilesExtend    = "FilesExtend"
	TypeTravelExtends  = "TravelExtends"
	TypeTravels        = "Travels"
	TypeUser           = "User"
	TypeUserExperience = "UserExperience"
	TypeUserProject    = "UserProject"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	nickname       *string
	account        *string
	password       *string
	email          *string
	description    *string
	avatar         *string
	blog_num       *int
	addblog_num    *int
	status         *int8
	addstatus      *int8
	clearedFields  map[string]struct{}
	travels        map[int]struct{}
	removedtravels map[int]struct{}
	clearedtravels bool
	done           bool
	oldValue       func(context.Context) (*Account, error)
	predicates     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *AccountMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AccountMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *AccountMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AccountMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AccountMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AccountMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
}

// SetAvatar sets the "avatar" field.
func (m *AccountMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AccountMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AccountMutation) ResetAvatar() {
	m.avatar = nil
}

// SetBlogNum sets the "blog_num" field.
func (m *AccountMutation) SetBlogNum(i int) {
	m.blog_num = &i
	m.addblog_num = nil
}

// BlogNum returns the value of the "blog_num" field in the mutation.
func (m *AccountMutation) BlogNum() (r int, exists bool) {
	v := m.blog_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogNum returns the old "blog_num" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBlogNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogNum: %w", err)
	}
	return oldValue.BlogNum, nil
}

// AddBlogNum adds i to the "blog_num" field.
func (m *AccountMutation) AddBlogNum(i int) {
	if m.addblog_num != nil {
		*m.addblog_num += i
	} else {
		m.addblog_num = &i
	}
}

// AddedBlogNum returns the value that was added to the "blog_num" field in this mutation.
func (m *AccountMutation) AddedBlogNum() (r int, exists bool) {
	v := m.addblog_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogNum resets all changes to the "blog_num" field.
func (m *AccountMutation) ResetBlogNum() {
	m.blog_num = nil
	m.addblog_num = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddTravelIDs adds the "travels" edge to the Travels entity by ids.
func (m *AccountMutation) AddTravelIDs(ids ...int) {
	if m.travels == nil {
		m.travels = make(map[int]struct{})
	}
	for i := range ids {
		m.travels[ids[i]] = struct{}{}
	}
}

// ClearTravels clears the "travels" edge to the Travels entity.
func (m *AccountMutation) ClearTravels() {
	m.clearedtravels = true
}

// TravelsCleared reports if the "travels" edge to the Travels entity was cleared.
func (m *AccountMutation) TravelsCleared() bool {
	return m.clearedtravels
}

// RemoveTravelIDs removes the "travels" edge to the Travels entity by IDs.
func (m *AccountMutation) RemoveTravelIDs(ids ...int) {
	if m.removedtravels == nil {
		m.removedtravels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.travels, ids[i])
		m.removedtravels[ids[i]] = struct{}{}
	}
}

// RemovedTravels returns the removed IDs of the "travels" edge to the Travels entity.
func (m *AccountMutation) RemovedTravelsIDs() (ids []int) {
	for id := range m.removedtravels {
		ids = append(ids, id)
	}
	return
}

// TravelsIDs returns the "travels" edge IDs in the mutation.
func (m *AccountMutation) TravelsIDs() (ids []int) {
	for id := range m.travels {
		ids = append(ids, id)
	}
	return
}

// ResetTravels resets all changes to the "travels" edge.
func (m *AccountMutation) ResetTravels() {
	m.travels = nil
	m.clearedtravels = false
	m.removedtravels = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.avatar != nil {
		fields = append(fields, account.FieldAvatar)
	}
	if m.blog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldCreatedBy:
		return m.CreatedBy()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldUpdatedBy:
		return m.UpdatedBy()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldDeletedBy:
		return m.DeletedBy()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldAccount:
		return m.Account()
	case account.FieldPassword:
		return m.Password()
	case account.FieldEmail:
		return m.Email()
	case account.FieldDescription:
		return m.Description()
	case account.FieldAvatar:
		return m.Avatar()
	case account.FieldBlogNum:
		return m.BlogNum()
	case account.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldAvatar:
		return m.OldAvatar(ctx)
	case account.FieldBlogNum:
		return m.OldBlogNum(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.addblog_num != nil {
		fields = append(fields, account.FieldBlogNum)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.AddedCreatedAt()
	case account.FieldCreatedBy:
		return m.AddedCreatedBy()
	case account.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case account.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case account.FieldDeletedAt:
		return m.AddedDeletedAt()
	case account.FieldDeletedBy:
		return m.AddedDeletedBy()
	case account.FieldBlogNum:
		return m.AddedBlogNum()
	case account.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case account.FieldBlogNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogNum(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldAvatar:
		m.ResetAvatar()
		return nil
	case account.FieldBlogNum:
		m.ResetBlogNum()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.travels != nil {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTravels:
		ids := make([]ent.Value, 0, len(m.travels))
		for id := range m.travels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtravels != nil {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTravels:
		ids := make([]ent.Value, 0, len(m.removedtravels))
		for id := range m.removedtravels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtravels {
		edges = append(edges, account.EdgeTravels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTravels:
		return m.clearedtravels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTravels:
		m.ResetTravels()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// BlogsMutation represents an operation that mutates the Blogs nodes in the graph.
type BlogsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	title         *string
	description   *string
	is_hidden     *int8
	addis_hidden  *int8
	tags          *[]string
	appendtags    []string
	cover         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Blogs, error)
	predicates    []predicate.Blogs
}

var _ ent.Mutation = (*BlogsMutation)(nil)

// blogsOption allows management of the mutation configuration using functional options.
type blogsOption func(*BlogsMutation)

// newBlogsMutation creates new mutation for the Blogs entity.
func newBlogsMutation(c config, op Op, opts ...blogsOption) *BlogsMutation {
	m := &BlogsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsID sets the ID field of the mutation.
func withBlogsID(id int) blogsOption {
	return func(m *BlogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Blogs
		)
		m.oldValue = func(ctx context.Context) (*Blogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogs sets the old Blogs of the mutation.
func withBlogs(node *Blogs) blogsOption {
	return func(m *BlogsMutation) {
		m.oldValue = func(context.Context) (*Blogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blogs entities.
func (m *BlogsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTitle sets the "title" field.
func (m *BlogsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlogsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogsMutation) ResetDescription() {
	m.description = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *BlogsMutation) SetIsHidden(i int8) {
	m.is_hidden = &i
	m.addis_hidden = nil
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *BlogsMutation) IsHidden() (r int8, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldIsHidden(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// AddIsHidden adds i to the "is_hidden" field.
func (m *BlogsMutation) AddIsHidden(i int8) {
	if m.addis_hidden != nil {
		*m.addis_hidden += i
	} else {
		m.addis_hidden = &i
	}
}

// AddedIsHidden returns the value that was added to the "is_hidden" field in this mutation.
func (m *BlogsMutation) AddedIsHidden() (r int8, exists bool) {
	v := m.addis_hidden
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *BlogsMutation) ResetIsHidden() {
	m.is_hidden = nil
	m.addis_hidden = nil
}

// SetTags sets the "tags" field.
func (m *BlogsMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *BlogsMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *BlogsMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *BlogsMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *BlogsMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCover sets the "cover" field.
func (m *BlogsMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *BlogsMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *BlogsMutation) ResetCover() {
	m.cover = nil
}

// Where appends a list predicates to the BlogsMutation builder.
func (m *BlogsMutation) Where(ps ...predicate.Blogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blogs).
func (m *BlogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.title != nil {
		fields = append(fields, blogs.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blogs.FieldDescription)
	}
	if m.is_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	if m.tags != nil {
		fields = append(fields, blogs.FieldTags)
	}
	if m.cover != nil {
		fields = append(fields, blogs.FieldCover)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.CreatedAt()
	case blogs.FieldCreatedBy:
		return m.CreatedBy()
	case blogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogs.FieldDeletedAt:
		return m.DeletedAt()
	case blogs.FieldDeletedBy:
		return m.DeletedBy()
	case blogs.FieldAccountID:
		return m.AccountID()
	case blogs.FieldTitle:
		return m.Title()
	case blogs.FieldDescription:
		return m.Description()
	case blogs.FieldIsHidden:
		return m.IsHidden()
	case blogs.FieldTags:
		return m.Tags()
	case blogs.FieldCover:
		return m.Cover()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogs.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogs.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogs.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogs.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogs.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogs.FieldTitle:
		return m.OldTitle(ctx)
	case blogs.FieldDescription:
		return m.OldDescription(ctx)
	case blogs.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case blogs.FieldTags:
		return m.OldTags(ctx)
	case blogs.FieldCover:
		return m.OldCover(ctx)
	}
	return nil, fmt.Errorf("unknown Blogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogs.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogs.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case blogs.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case blogs.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogs.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogs.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogs.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogs.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogs.FieldAccountID)
	}
	if m.addis_hidden != nil {
		fields = append(fields, blogs.FieldIsHidden)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogs.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogs.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogs.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogs.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogs.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogs.FieldAccountID:
		return m.AddedAccountID()
	case blogs.FieldIsHidden:
		return m.AddedIsHidden()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogs.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogs.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogs.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogs.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogs.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogs.FieldIsHidden:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsMutation) ResetField(name string) error {
	switch name {
	case blogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogs.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogs.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogs.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogs.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogs.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogs.FieldTitle:
		m.ResetTitle()
		return nil
	case blogs.FieldDescription:
		m.ResetDescription()
		return nil
	case blogs.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case blogs.FieldTags:
		m.ResetTags()
		return nil
	case blogs.FieldCover:
		m.ResetCover()
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blogs edge %s", name)
}

// BlogsCommentMutation represents an operation that mutates the BlogsComment nodes in the graph.
type BlogsCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	account_id    *int
	addaccount_id *int
	blog_id       *int
	addblog_id    *int
	top_id        *int
	addtop_id     *int
	parent_id     *int
	addparent_id  *int
	level         *int
	addlevel      *int
	total         *int
	addtotal      *int
	status        *int8
	addstatus     *int8
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsComment, error)
	predicates    []predicate.BlogsComment
}

var _ ent.Mutation = (*BlogsCommentMutation)(nil)

// blogscommentOption allows management of the mutation configuration using functional options.
type blogscommentOption func(*BlogsCommentMutation)

// newBlogsCommentMutation creates new mutation for the BlogsComment entity.
func newBlogsCommentMutation(c config, op Op, opts ...blogscommentOption) *BlogsCommentMutation {
	m := &BlogsCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsCommentID sets the ID field of the mutation.
func withBlogsCommentID(id int) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsComment
		)
		m.oldValue = func(ctx context.Context) (*BlogsComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsComment sets the old BlogsComment of the mutation.
func withBlogsComment(node *BlogsComment) blogscommentOption {
	return func(m *BlogsCommentMutation) {
		m.oldValue = func(context.Context) (*BlogsComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsComment entities.
func (m *BlogsCommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsCommentMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsCommentMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BlogsCommentMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsCommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BlogsCommentMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BlogsCommentMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BlogsCommentMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BlogsCommentMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BlogsCommentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsCommentMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsCommentMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BlogsCommentMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BlogsCommentMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BlogsCommentMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BlogsCommentMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BlogsCommentMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BlogsCommentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlogsCommentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlogsCommentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BlogsCommentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlogsCommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BlogsCommentMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BlogsCommentMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BlogsCommentMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BlogsCommentMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BlogsCommentMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *BlogsCommentMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *BlogsCommentMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *BlogsCommentMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *BlogsCommentMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *BlogsCommentMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetBlogID sets the "blog_id" field.
func (m *BlogsCommentMutation) SetBlogID(i int) {
	m.blog_id = &i
	m.addblog_id = nil
}

// BlogID returns the value of the "blog_id" field in the mutation.
func (m *BlogsCommentMutation) BlogID() (r int, exists bool) {
	v := m.blog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogID returns the old "blog_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldBlogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogID: %w", err)
	}
	return oldValue.BlogID, nil
}

// AddBlogID adds i to the "blog_id" field.
func (m *BlogsCommentMutation) AddBlogID(i int) {
	if m.addblog_id != nil {
		*m.addblog_id += i
	} else {
		m.addblog_id = &i
	}
}

// AddedBlogID returns the value that was added to the "blog_id" field in this mutation.
func (m *BlogsCommentMutation) AddedBlogID() (r int, exists bool) {
	v := m.addblog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogID resets all changes to the "blog_id" field.
func (m *BlogsCommentMutation) ResetBlogID() {
	m.blog_id = nil
	m.addblog_id = nil
}

// SetTopID sets the "top_id" field.
func (m *BlogsCommentMutation) SetTopID(i int) {
	m.top_id = &i
	m.addtop_id = nil
}

// TopID returns the value of the "top_id" field in the mutation.
func (m *BlogsCommentMutation) TopID() (r int, exists bool) {
	v := m.top_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopID returns the old "top_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopID: %w", err)
	}
	return oldValue.TopID, nil
}

// AddTopID adds i to the "top_id" field.
func (m *BlogsCommentMutation) AddTopID(i int) {
	if m.addtop_id != nil {
		*m.addtop_id += i
	} else {
		m.addtop_id = &i
	}
}

// AddedTopID returns the value that was added to the "top_id" field in this mutation.
func (m *BlogsCommentMutation) AddedTopID() (r int, exists bool) {
	v := m.addtop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopID resets all changes to the "top_id" field.
func (m *BlogsCommentMutation) ResetTopID() {
	m.top_id = nil
	m.addtop_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *BlogsCommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BlogsCommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *BlogsCommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *BlogsCommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BlogsCommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetLevel sets the "level" field.
func (m *BlogsCommentMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *BlogsCommentMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *BlogsCommentMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *BlogsCommentMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *BlogsCommentMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetTotal sets the "total" field.
func (m *BlogsCommentMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *BlogsCommentMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *BlogsCommentMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *BlogsCommentMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *BlogsCommentMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetStatus sets the "status" field.
func (m *BlogsCommentMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogsCommentMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BlogsCommentMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BlogsCommentMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogsCommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetContent sets the "content" field.
func (m *BlogsCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsComment entity.
// If the BlogsComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsCommentMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the BlogsCommentMutation builder.
func (m *BlogsCommentMutation) Where(ps ...predicate.BlogsComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsComment).
func (m *BlogsCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsCommentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.blog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.top_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.parent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.level != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.total != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.status != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, blogscomment.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.CreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.CreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.UpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.DeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.DeletedBy()
	case blogscomment.FieldAccountID:
		return m.AccountID()
	case blogscomment.FieldBlogID:
		return m.BlogID()
	case blogscomment.FieldTopID:
		return m.TopID()
	case blogscomment.FieldParentID:
		return m.ParentID()
	case blogscomment.FieldLevel:
		return m.Level()
	case blogscomment.FieldTotal:
		return m.Total()
	case blogscomment.FieldStatus:
		return m.Status()
	case blogscomment.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogscomment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case blogscomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blogscomment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case blogscomment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blogscomment.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case blogscomment.FieldAccountID:
		return m.OldAccountID(ctx)
	case blogscomment.FieldBlogID:
		return m.OldBlogID(ctx)
	case blogscomment.FieldTopID:
		return m.OldTopID(ctx)
	case blogscomment.FieldParentID:
		return m.OldParentID(ctx)
	case blogscomment.FieldLevel:
		return m.OldLevel(ctx)
	case blogscomment.FieldTotal:
		return m.OldTotal(ctx)
	case blogscomment.FieldStatus:
		return m.OldStatus(ctx)
	case blogscomment.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogscomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsCommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, blogscomment.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, blogscomment.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, blogscomment.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, blogscomment.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, blogscomment.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, blogscomment.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, blogscomment.FieldAccountID)
	}
	if m.addblog_id != nil {
		fields = append(fields, blogscomment.FieldBlogID)
	}
	if m.addtop_id != nil {
		fields = append(fields, blogscomment.FieldTopID)
	}
	if m.addparent_id != nil {
		fields = append(fields, blogscomment.FieldParentID)
	}
	if m.addlevel != nil {
		fields = append(fields, blogscomment.FieldLevel)
	}
	if m.addtotal != nil {
		fields = append(fields, blogscomment.FieldTotal)
	}
	if m.addstatus != nil {
		fields = append(fields, blogscomment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogscomment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case blogscomment.FieldCreatedBy:
		return m.AddedCreatedBy()
	case blogscomment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case blogscomment.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case blogscomment.FieldDeletedAt:
		return m.AddedDeletedAt()
	case blogscomment.FieldDeletedBy:
		return m.AddedDeletedBy()
	case blogscomment.FieldAccountID:
		return m.AddedAccountID()
	case blogscomment.FieldBlogID:
		return m.AddedBlogID()
	case blogscomment.FieldTopID:
		return m.AddedTopID()
	case blogscomment.FieldParentID:
		return m.AddedParentID()
	case blogscomment.FieldLevel:
		return m.AddedLevel()
	case blogscomment.FieldTotal:
		return m.AddedTotal()
	case blogscomment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case blogscomment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case blogscomment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case blogscomment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case blogscomment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case blogscomment.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case blogscomment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case blogscomment.FieldBlogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlogID(v)
		return nil
	case blogscomment.FieldTopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopID(v)
		return nil
	case blogscomment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case blogscomment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case blogscomment.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case blogscomment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsCommentMutation) ResetField(name string) error {
	switch name {
	case blogscomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogscomment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case blogscomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blogscomment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case blogscomment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blogscomment.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case blogscomment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case blogscomment.FieldBlogID:
		m.ResetBlogID()
		return nil
	case blogscomment.FieldTopID:
		m.ResetTopID()
		return nil
	case blogscomment.FieldParentID:
		m.ResetParentID()
		return nil
	case blogscomment.FieldLevel:
		m.ResetLevel()
		return nil
	case blogscomment.FieldTotal:
		m.ResetTotal()
		return nil
	case blogscomment.FieldStatus:
		m.ResetStatus()
		return nil
	case blogscomment.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown BlogsComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsCommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsCommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsCommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsCommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsComment edge %s", name)
}

// BlogsContentMutation represents an operation that mutates the BlogsContent nodes in the graph.
type BlogsContentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	files         *[]string
	appendfiles   []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlogsContent, error)
	predicates    []predicate.BlogsContent
}

var _ ent.Mutation = (*BlogsContentMutation)(nil)

// blogscontentOption allows management of the mutation configuration using functional options.
type blogscontentOption func(*BlogsContentMutation)

// newBlogsContentMutation creates new mutation for the BlogsContent entity.
func newBlogsContentMutation(c config, op Op, opts ...blogscontentOption) *BlogsContentMutation {
	m := &BlogsContentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogsContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsContentID sets the ID field of the mutation.
func withBlogsContentID(id int) blogscontentOption {
	return func(m *BlogsContentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogsContent
		)
		m.oldValue = func(ctx context.Context) (*BlogsContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogsContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogsContent sets the old BlogsContent of the mutation.
func withBlogsContent(node *BlogsContent) blogscontentOption {
	return func(m *BlogsContentMutation) {
		m.oldValue = func(context.Context) (*BlogsContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogsContent entities.
func (m *BlogsContentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsContentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsContentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogsContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *BlogsContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogsContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogsContent entity.
// If the BlogsContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogsContentMutation) ResetContent() {
	m.content = nil
}

// SetFiles sets the "files" field.
func (m *BlogsContentMutation) SetFiles(s []string) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *BlogsContentMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the BlogsContent entity.
// If the BlogsContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsContentMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *BlogsContentMutation) AppendFiles(s []string) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *BlogsContentMutation) AppendedFiles() ([]string, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ResetFiles resets all changes to the "files" field.
func (m *BlogsContentMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
}

// Where appends a list predicates to the BlogsContentMutation builder.
func (m *BlogsContentMutation) Where(ps ...predicate.BlogsContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogsContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogsContent).
func (m *BlogsContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsContentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.content != nil {
		fields = append(fields, blogscontent.FieldContent)
	}
	if m.files != nil {
		fields = append(fields, blogscontent.FieldFiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogscontent.FieldContent:
		return m.Content()
	case blogscontent.FieldFiles:
		return m.Files()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogscontent.FieldContent:
		return m.OldContent(ctx)
	case blogscontent.FieldFiles:
		return m.OldFiles(ctx)
	}
	return nil, fmt.Errorf("unknown BlogsContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogscontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogscontent.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogsContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsContentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsContentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogsContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsContentMutation) ResetField(name string) error {
	switch name {
	case blogscontent.FieldContent:
		m.ResetContent()
		return nil
	case blogscontent.FieldFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown BlogsContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsContentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsContentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsContentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsContentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlogsContent edge %s", name)
}

// FilesMutation represents an operation that mutates the Files nodes in the graph.
type FilesMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	_type         *string
	size          *int64
	addsize       *int64
	name          *string
	_path         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Files, error)
	predicates    []predicate.Files
}

var _ ent.Mutation = (*FilesMutation)(nil)

// filesOption allows management of the mutation configuration using functional options.
type filesOption func(*FilesMutation)

// newFilesMutation creates new mutation for the Files entity.
func newFilesMutation(c config, op Op, opts ...filesOption) *FilesMutation {
	m := &FilesMutation{
		config:        c,
		op:            op,
		typ:           TypeFiles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesID sets the ID field of the mutation.
func withFilesID(id string) filesOption {
	return func(m *FilesMutation) {
		var (
			err   error
			once  sync.Once
			value *Files
		)
		m.oldValue = func(ctx context.Context) (*Files, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Files.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFiles sets the old Files of the mutation.
func withFiles(node *Files) filesOption {
	return func(m *FilesMutation) {
		m.oldValue = func(context.Context) (*Files, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Files entities.
func (m *FilesMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Files.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetType sets the "type" field.
func (m *FilesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FilesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FilesMutation) ResetType() {
	m._type = nil
}

// SetSize sets the "size" field.
func (m *FilesMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FilesMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FilesMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FilesMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FilesMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetName sets the "name" field.
func (m *FilesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FilesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FilesMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FilesMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FilesMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Files entity.
// If the Files object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FilesMutation) ResetPath() {
	m._path = nil
}

// Where appends a list predicates to the FilesMutation builder.
func (m *FilesMutation) Where(ps ...predicate.Files) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Files, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Files).
func (m *FilesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m._type != nil {
		fields = append(fields, files.FieldType)
	}
	if m.size != nil {
		fields = append(fields, files.FieldSize)
	}
	if m.name != nil {
		fields = append(fields, files.FieldName)
	}
	if m._path != nil {
		fields = append(fields, files.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.CreatedAt()
	case files.FieldCreatedBy:
		return m.CreatedBy()
	case files.FieldUpdatedAt:
		return m.UpdatedAt()
	case files.FieldUpdatedBy:
		return m.UpdatedBy()
	case files.FieldDeletedAt:
		return m.DeletedAt()
	case files.FieldDeletedBy:
		return m.DeletedBy()
	case files.FieldType:
		return m.GetType()
	case files.FieldSize:
		return m.Size()
	case files.FieldName:
		return m.Name()
	case files.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case files.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case files.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case files.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case files.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case files.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case files.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case files.FieldType:
		return m.OldType(ctx)
	case files.FieldSize:
		return m.OldSize(ctx)
	case files.FieldName:
		return m.OldName(ctx)
	case files.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Files field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case files.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case files.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case files.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, files.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, files.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, files.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, files.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, files.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, files.FieldDeletedBy)
	}
	if m.addsize != nil {
		fields = append(fields, files.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case files.FieldCreatedAt:
		return m.AddedCreatedAt()
	case files.FieldCreatedBy:
		return m.AddedCreatedBy()
	case files.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case files.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case files.FieldDeletedAt:
		return m.AddedDeletedAt()
	case files.FieldDeletedBy:
		return m.AddedDeletedBy()
	case files.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case files.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case files.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case files.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case files.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case files.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case files.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case files.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Files numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Files nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesMutation) ResetField(name string) error {
	switch name {
	case files.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case files.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case files.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case files.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case files.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case files.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case files.FieldType:
		m.ResetType()
		return nil
	case files.FieldSize:
		m.ResetSize()
		return nil
	case files.FieldName:
		m.ResetName()
		return nil
	case files.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Files field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Files unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Files edge %s", name)
}

// FilesExtendMutation represents an operation that mutates the FilesExtend nodes in the graph.
type FilesExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	file_id       *string
	user_id       *int
	adduser_id    *int
	from          *string
	from_id       *int
	addfrom_id    *int
	is_hidden     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FilesExtend, error)
	predicates    []predicate.FilesExtend
}

var _ ent.Mutation = (*FilesExtendMutation)(nil)

// filesextendOption allows management of the mutation configuration using functional options.
type filesextendOption func(*FilesExtendMutation)

// newFilesExtendMutation creates new mutation for the FilesExtend entity.
func newFilesExtendMutation(c config, op Op, opts ...filesextendOption) *FilesExtendMutation {
	m := &FilesExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeFilesExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilesExtendID sets the ID field of the mutation.
func withFilesExtendID(id int) filesextendOption {
	return func(m *FilesExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *FilesExtend
		)
		m.oldValue = func(ctx context.Context) (*FilesExtend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilesExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilesExtend sets the old FilesExtend of the mutation.
func withFilesExtend(node *FilesExtend) filesextendOption {
	return func(m *FilesExtendMutation) {
		m.oldValue = func(context.Context) (*FilesExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilesExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilesExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FilesExtend entities.
func (m *FilesExtendMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilesExtendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilesExtendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilesExtend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FilesExtendMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilesExtendMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FilesExtendMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilesExtendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FilesExtendMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FilesExtendMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FilesExtendMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FilesExtendMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FilesExtendMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilesExtendMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilesExtendMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FilesExtendMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilesExtendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FilesExtendMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FilesExtendMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FilesExtendMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FilesExtendMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FilesExtendMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FilesExtendMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FilesExtendMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FilesExtendMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FilesExtendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FilesExtendMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FilesExtendMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FilesExtendMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FilesExtendMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FilesExtendMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetFileID sets the "file_id" field.
func (m *FilesExtendMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FilesExtendMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FilesExtendMutation) ResetFileID() {
	m.file_id = nil
}

// SetUserID sets the "user_id" field.
func (m *FilesExtendMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FilesExtendMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FilesExtendMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FilesExtendMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FilesExtendMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetFrom sets the "from" field.
func (m *FilesExtendMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *FilesExtendMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *FilesExtendMutation) ResetFrom() {
	m.from = nil
}

// SetFromID sets the "from_id" field.
func (m *FilesExtendMutation) SetFromID(i int) {
	m.from_id = &i
	m.addfrom_id = nil
}

// FromID returns the value of the "from_id" field in the mutation.
func (m *FilesExtendMutation) FromID() (r int, exists bool) {
	v := m.from_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromID returns the old "from_id" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldFromID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromID: %w", err)
	}
	return oldValue.FromID, nil
}

// AddFromID adds i to the "from_id" field.
func (m *FilesExtendMutation) AddFromID(i int) {
	if m.addfrom_id != nil {
		*m.addfrom_id += i
	} else {
		m.addfrom_id = &i
	}
}

// AddedFromID returns the value that was added to the "from_id" field in this mutation.
func (m *FilesExtendMutation) AddedFromID() (r int, exists bool) {
	v := m.addfrom_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromID resets all changes to the "from_id" field.
func (m *FilesExtendMutation) ResetFromID() {
	m.from_id = nil
	m.addfrom_id = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *FilesExtendMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *FilesExtendMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the FilesExtend entity.
// If the FilesExtend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilesExtendMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *FilesExtendMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// Where appends a list predicates to the FilesExtendMutation builder.
func (m *FilesExtendMutation) Where(ps ...predicate.FilesExtend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilesExtendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilesExtendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FilesExtend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilesExtendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilesExtendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FilesExtend).
func (m *FilesExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilesExtendMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.file_id != nil {
		fields = append(fields, filesextend.FieldFileID)
	}
	if m.user_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.from != nil {
		fields = append(fields, filesextend.FieldFrom)
	}
	if m.from_id != nil {
		fields = append(fields, filesextend.FieldFromID)
	}
	if m.is_hidden != nil {
		fields = append(fields, filesextend.FieldIsHidden)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilesExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.CreatedAt()
	case filesextend.FieldCreatedBy:
		return m.CreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.UpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.UpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.DeletedAt()
	case filesextend.FieldDeletedBy:
		return m.DeletedBy()
	case filesextend.FieldFileID:
		return m.FileID()
	case filesextend.FieldUserID:
		return m.UserID()
	case filesextend.FieldFrom:
		return m.From()
	case filesextend.FieldFromID:
		return m.FromID()
	case filesextend.FieldIsHidden:
		return m.IsHidden()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilesExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filesextend.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filesextend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filesextend.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filesextend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case filesextend.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case filesextend.FieldFileID:
		return m.OldFileID(ctx)
	case filesextend.FieldUserID:
		return m.OldUserID(ctx)
	case filesextend.FieldFrom:
		return m.OldFrom(ctx)
	case filesextend.FieldFromID:
		return m.OldFromID(ctx)
	case filesextend.FieldIsHidden:
		return m.OldIsHidden(ctx)
	}
	return nil, fmt.Errorf("unknown FilesExtend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case filesextend.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case filesextend.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case filesextend.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromID(v)
		return nil
	case filesextend.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilesExtendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, filesextend.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, filesextend.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, filesextend.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, filesextend.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, filesextend.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, filesextend.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, filesextend.FieldUserID)
	}
	if m.addfrom_id != nil {
		fields = append(fields, filesextend.FieldFromID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilesExtendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filesextend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case filesextend.FieldCreatedBy:
		return m.AddedCreatedBy()
	case filesextend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case filesextend.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case filesextend.FieldDeletedAt:
		return m.AddedDeletedAt()
	case filesextend.FieldDeletedBy:
		return m.AddedDeletedBy()
	case filesextend.FieldUserID:
		return m.AddedUserID()
	case filesextend.FieldFromID:
		return m.AddedFromID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilesExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filesextend.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case filesextend.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case filesextend.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case filesextend.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case filesextend.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case filesextend.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case filesextend.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case filesextend.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromID(v)
		return nil
	}
	return fmt.Errorf("unknown FilesExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilesExtendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilesExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilesExtendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FilesExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilesExtendMutation) ResetField(name string) error {
	switch name {
	case filesextend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filesextend.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filesextend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filesextend.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filesextend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case filesextend.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case filesextend.FieldFileID:
		m.ResetFileID()
		return nil
	case filesextend.FieldUserID:
		m.ResetUserID()
		return nil
	case filesextend.FieldFrom:
		m.ResetFrom()
		return nil
	case filesextend.FieldFromID:
		m.ResetFromID()
		return nil
	case filesextend.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	}
	return fmt.Errorf("unknown FilesExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilesExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilesExtendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilesExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilesExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilesExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilesExtendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilesExtendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FilesExtend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilesExtendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FilesExtend edge %s", name)
}

// TravelExtendsMutation represents an operation that mutates the TravelExtends nodes in the graph.
type TravelExtendsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *int64
	addcreated_at  *int64
	created_by     *int64
	addcreated_by  *int64
	updated_at     *int64
	addupdated_at  *int64
	updated_by     *int64
	addupdated_by  *int64
	deleted_at     *int64
	adddeleted_at  *int64
	deleted_by     *int64
	adddeleted_by  *int64
	account_id     *int
	addaccount_id  *int
	is_thumb       *bool
	is_collect     *bool
	clearedFields  map[string]struct{}
	extends        *int
	clearedextends bool
	done           bool
	oldValue       func(context.Context) (*TravelExtends, error)
	predicates     []predicate.TravelExtends
}

var _ ent.Mutation = (*TravelExtendsMutation)(nil)

// travelextendsOption allows management of the mutation configuration using functional options.
type travelextendsOption func(*TravelExtendsMutation)

// newTravelExtendsMutation creates new mutation for the TravelExtends entity.
func newTravelExtendsMutation(c config, op Op, opts ...travelextendsOption) *TravelExtendsMutation {
	m := &TravelExtendsMutation{
		config:        c,
		op:            op,
		typ:           TypeTravelExtends,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelExtendsID sets the ID field of the mutation.
func withTravelExtendsID(id int) travelextendsOption {
	return func(m *TravelExtendsMutation) {
		var (
			err   error
			once  sync.Once
			value *TravelExtends
		)
		m.oldValue = func(ctx context.Context) (*TravelExtends, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TravelExtends.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravelExtends sets the old TravelExtends of the mutation.
func withTravelExtends(node *TravelExtends) travelextendsOption {
	return func(m *TravelExtendsMutation) {
		m.oldValue = func(context.Context) (*TravelExtends, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelExtendsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelExtendsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelExtendsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelExtendsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TravelExtends.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelExtendsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelExtendsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelExtendsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelExtendsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelExtendsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelExtendsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelExtendsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelExtendsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelExtendsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelExtendsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelExtendsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelExtendsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelExtendsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelExtendsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelExtendsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelExtendsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelExtendsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelExtendsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelExtendsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelExtendsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelExtendsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelExtendsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelExtendsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelExtendsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelExtendsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelExtendsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelExtendsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelExtendsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelExtendsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelExtendsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetAccountID sets the "account_id" field.
func (m *TravelExtendsMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TravelExtendsMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *TravelExtendsMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *TravelExtendsMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TravelExtendsMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetTravelID sets the "travel_id" field.
func (m *TravelExtendsMutation) SetTravelID(i int) {
	m.extends = &i
}

// TravelID returns the value of the "travel_id" field in the mutation.
func (m *TravelExtendsMutation) TravelID() (r int, exists bool) {
	v := m.extends
	if v == nil {
		return
	}
	return *v, true
}

// OldTravelID returns the old "travel_id" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldTravelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTravelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTravelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTravelID: %w", err)
	}
	return oldValue.TravelID, nil
}

// ClearTravelID clears the value of the "travel_id" field.
func (m *TravelExtendsMutation) ClearTravelID() {
	m.extends = nil
	m.clearedFields[travelextends.FieldTravelID] = struct{}{}
}

// TravelIDCleared returns if the "travel_id" field was cleared in this mutation.
func (m *TravelExtendsMutation) TravelIDCleared() bool {
	_, ok := m.clearedFields[travelextends.FieldTravelID]
	return ok
}

// ResetTravelID resets all changes to the "travel_id" field.
func (m *TravelExtendsMutation) ResetTravelID() {
	m.extends = nil
	delete(m.clearedFields, travelextends.FieldTravelID)
}

// SetIsThumb sets the "is_thumb" field.
func (m *TravelExtendsMutation) SetIsThumb(b bool) {
	m.is_thumb = &b
}

// IsThumb returns the value of the "is_thumb" field in the mutation.
func (m *TravelExtendsMutation) IsThumb() (r bool, exists bool) {
	v := m.is_thumb
	if v == nil {
		return
	}
	return *v, true
}

// OldIsThumb returns the old "is_thumb" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldIsThumb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsThumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsThumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsThumb: %w", err)
	}
	return oldValue.IsThumb, nil
}

// ResetIsThumb resets all changes to the "is_thumb" field.
func (m *TravelExtendsMutation) ResetIsThumb() {
	m.is_thumb = nil
}

// SetIsCollect sets the "is_collect" field.
func (m *TravelExtendsMutation) SetIsCollect(b bool) {
	m.is_collect = &b
}

// IsCollect returns the value of the "is_collect" field in the mutation.
func (m *TravelExtendsMutation) IsCollect() (r bool, exists bool) {
	v := m.is_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCollect returns the old "is_collect" field's value of the TravelExtends entity.
// If the TravelExtends object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelExtendsMutation) OldIsCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCollect: %w", err)
	}
	return oldValue.IsCollect, nil
}

// ResetIsCollect resets all changes to the "is_collect" field.
func (m *TravelExtendsMutation) ResetIsCollect() {
	m.is_collect = nil
}

// SetExtendsID sets the "extends" edge to the Travels entity by id.
func (m *TravelExtendsMutation) SetExtendsID(id int) {
	m.extends = &id
}

// ClearExtends clears the "extends" edge to the Travels entity.
func (m *TravelExtendsMutation) ClearExtends() {
	m.clearedextends = true
	m.clearedFields[travelextends.FieldTravelID] = struct{}{}
}

// ExtendsCleared reports if the "extends" edge to the Travels entity was cleared.
func (m *TravelExtendsMutation) ExtendsCleared() bool {
	return m.TravelIDCleared() || m.clearedextends
}

// ExtendsID returns the "extends" edge ID in the mutation.
func (m *TravelExtendsMutation) ExtendsID() (id int, exists bool) {
	if m.extends != nil {
		return *m.extends, true
	}
	return
}

// ExtendsIDs returns the "extends" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtendsID instead. It exists only for internal usage by the builders.
func (m *TravelExtendsMutation) ExtendsIDs() (ids []int) {
	if id := m.extends; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtends resets all changes to the "extends" edge.
func (m *TravelExtendsMutation) ResetExtends() {
	m.extends = nil
	m.clearedextends = false
}

// Where appends a list predicates to the TravelExtendsMutation builder.
func (m *TravelExtendsMutation) Where(ps ...predicate.TravelExtends) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelExtendsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelExtendsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TravelExtends, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelExtendsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelExtendsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TravelExtends).
func (m *TravelExtendsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelExtendsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, travelextends.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travelextends.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travelextends.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travelextends.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travelextends.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travelextends.FieldDeletedBy)
	}
	if m.account_id != nil {
		fields = append(fields, travelextends.FieldAccountID)
	}
	if m.extends != nil {
		fields = append(fields, travelextends.FieldTravelID)
	}
	if m.is_thumb != nil {
		fields = append(fields, travelextends.FieldIsThumb)
	}
	if m.is_collect != nil {
		fields = append(fields, travelextends.FieldIsCollect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelExtendsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.CreatedAt()
	case travelextends.FieldCreatedBy:
		return m.CreatedBy()
	case travelextends.FieldUpdatedAt:
		return m.UpdatedAt()
	case travelextends.FieldUpdatedBy:
		return m.UpdatedBy()
	case travelextends.FieldDeletedAt:
		return m.DeletedAt()
	case travelextends.FieldDeletedBy:
		return m.DeletedBy()
	case travelextends.FieldAccountID:
		return m.AccountID()
	case travelextends.FieldTravelID:
		return m.TravelID()
	case travelextends.FieldIsThumb:
		return m.IsThumb()
	case travelextends.FieldIsCollect:
		return m.IsCollect()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelExtendsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travelextends.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travelextends.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travelextends.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travelextends.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travelextends.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travelextends.FieldAccountID:
		return m.OldAccountID(ctx)
	case travelextends.FieldTravelID:
		return m.OldTravelID(ctx)
	case travelextends.FieldIsThumb:
		return m.OldIsThumb(ctx)
	case travelextends.FieldIsCollect:
		return m.OldIsCollect(ctx)
	}
	return nil, fmt.Errorf("unknown TravelExtends field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travelextends.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travelextends.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travelextends.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travelextends.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travelextends.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travelextends.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travelextends.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case travelextends.FieldTravelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTravelID(v)
		return nil
	case travelextends.FieldIsThumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsThumb(v)
		return nil
	case travelextends.FieldIsCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCollect(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtends field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelExtendsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travelextends.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travelextends.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travelextends.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travelextends.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travelextends.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travelextends.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, travelextends.FieldAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelExtendsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travelextends.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travelextends.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travelextends.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travelextends.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travelextends.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travelextends.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travelextends.FieldAccountID:
		return m.AddedAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelExtendsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travelextends.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travelextends.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travelextends.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travelextends.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travelextends.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travelextends.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travelextends.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown TravelExtends numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelExtendsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(travelextends.FieldTravelID) {
		fields = append(fields, travelextends.FieldTravelID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelExtendsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelExtendsMutation) ClearField(name string) error {
	switch name {
	case travelextends.FieldTravelID:
		m.ClearTravelID()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelExtendsMutation) ResetField(name string) error {
	switch name {
	case travelextends.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travelextends.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travelextends.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travelextends.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travelextends.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travelextends.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travelextends.FieldAccountID:
		m.ResetAccountID()
		return nil
	case travelextends.FieldTravelID:
		m.ResetTravelID()
		return nil
	case travelextends.FieldIsThumb:
		m.ResetIsThumb()
		return nil
	case travelextends.FieldIsCollect:
		m.ResetIsCollect()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelExtendsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extends != nil {
		edges = append(edges, travelextends.EdgeExtends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelExtendsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case travelextends.EdgeExtends:
		if id := m.extends; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelExtendsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelExtendsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelExtendsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextends {
		edges = append(edges, travelextends.EdgeExtends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelExtendsMutation) EdgeCleared(name string) bool {
	switch name {
	case travelextends.EdgeExtends:
		return m.clearedextends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelExtendsMutation) ClearEdge(name string) error {
	switch name {
	case travelextends.EdgeExtends:
		m.ClearExtends()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelExtendsMutation) ResetEdge(name string) error {
	switch name {
	case travelextends.EdgeExtends:
		m.ResetExtends()
		return nil
	}
	return fmt.Errorf("unknown TravelExtends edge %s", name)
}

// TravelsMutation represents an operation that mutates the Travels nodes in the graph.
type TravelsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *int64
	addcreated_at         *int64
	created_by            *int64
	addcreated_by         *int64
	updated_at            *int64
	addupdated_at         *int64
	updated_by            *int64
	addupdated_by         *int64
	deleted_at            *int64
	adddeleted_at         *int64
	deleted_by            *int64
	adddeleted_by         *int64
	title                 *string
	description           *string
	video                 *string
	is_hidden             *bool
	photos                *[]string
	appendphotos          []string
	browse_num            *int
	addbrowse_num         *int
	thumb_num             *int
	addthumb_num          *int
	collect_num           *int
	addcollect_num        *int
	clearedFields         map[string]struct{}
	travel_extends        map[int]struct{}
	removedtravel_extends map[int]struct{}
	clearedtravel_extends bool
	travel_account        *int
	clearedtravel_account bool
	done                  bool
	oldValue              func(context.Context) (*Travels, error)
	predicates            []predicate.Travels
}

var _ ent.Mutation = (*TravelsMutation)(nil)

// travelsOption allows management of the mutation configuration using functional options.
type travelsOption func(*TravelsMutation)

// newTravelsMutation creates new mutation for the Travels entity.
func newTravelsMutation(c config, op Op, opts ...travelsOption) *TravelsMutation {
	m := &TravelsMutation{
		config:        c,
		op:            op,
		typ:           TypeTravels,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTravelsID sets the ID field of the mutation.
func withTravelsID(id int) travelsOption {
	return func(m *TravelsMutation) {
		var (
			err   error
			once  sync.Once
			value *Travels
		)
		m.oldValue = func(ctx context.Context) (*Travels, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Travels.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTravels sets the old Travels of the mutation.
func withTravels(node *Travels) travelsOption {
	return func(m *TravelsMutation) {
		m.oldValue = func(context.Context) (*Travels, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TravelsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TravelsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Travels entities.
func (m *TravelsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TravelsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TravelsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Travels.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TravelsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TravelsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TravelsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TravelsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TravelsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TravelsMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TravelsMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TravelsMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TravelsMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TravelsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TravelsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TravelsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TravelsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TravelsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TravelsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TravelsMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TravelsMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TravelsMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TravelsMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TravelsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TravelsMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TravelsMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TravelsMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TravelsMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TravelsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TravelsMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TravelsMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TravelsMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TravelsMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TravelsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetTitle sets the "title" field.
func (m *TravelsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TravelsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TravelsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TravelsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TravelsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TravelsMutation) ResetDescription() {
	m.description = nil
}

// SetVideo sets the "video" field.
func (m *TravelsMutation) SetVideo(s string) {
	m.video = &s
}

// Video returns the value of the "video" field in the mutation.
func (m *TravelsMutation) Video() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideo returns the old "video" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldVideo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideo: %w", err)
	}
	return oldValue.Video, nil
}

// ResetVideo resets all changes to the "video" field.
func (m *TravelsMutation) ResetVideo() {
	m.video = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *TravelsMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *TravelsMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *TravelsMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetAccountID sets the "account_id" field.
func (m *TravelsMutation) SetAccountID(i int) {
	m.travel_account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TravelsMutation) AccountID() (r int, exists bool) {
	v := m.travel_account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *TravelsMutation) ClearAccountID() {
	m.travel_account = nil
	m.clearedFields[travels.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *TravelsMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[travels.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TravelsMutation) ResetAccountID() {
	m.travel_account = nil
	delete(m.clearedFields, travels.FieldAccountID)
}

// SetPhotos sets the "photos" field.
func (m *TravelsMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *TravelsMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *TravelsMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *TravelsMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *TravelsMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// SetBrowseNum sets the "browse_num" field.
func (m *TravelsMutation) SetBrowseNum(i int) {
	m.browse_num = &i
	m.addbrowse_num = nil
}

// BrowseNum returns the value of the "browse_num" field in the mutation.
func (m *TravelsMutation) BrowseNum() (r int, exists bool) {
	v := m.browse_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseNum returns the old "browse_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldBrowseNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseNum: %w", err)
	}
	return oldValue.BrowseNum, nil
}

// AddBrowseNum adds i to the "browse_num" field.
func (m *TravelsMutation) AddBrowseNum(i int) {
	if m.addbrowse_num != nil {
		*m.addbrowse_num += i
	} else {
		m.addbrowse_num = &i
	}
}

// AddedBrowseNum returns the value that was added to the "browse_num" field in this mutation.
func (m *TravelsMutation) AddedBrowseNum() (r int, exists bool) {
	v := m.addbrowse_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrowseNum resets all changes to the "browse_num" field.
func (m *TravelsMutation) ResetBrowseNum() {
	m.browse_num = nil
	m.addbrowse_num = nil
}

// SetThumbNum sets the "thumb_num" field.
func (m *TravelsMutation) SetThumbNum(i int) {
	m.thumb_num = &i
	m.addthumb_num = nil
}

// ThumbNum returns the value of the "thumb_num" field in the mutation.
func (m *TravelsMutation) ThumbNum() (r int, exists bool) {
	v := m.thumb_num
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbNum returns the old "thumb_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldThumbNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbNum: %w", err)
	}
	return oldValue.ThumbNum, nil
}

// AddThumbNum adds i to the "thumb_num" field.
func (m *TravelsMutation) AddThumbNum(i int) {
	if m.addthumb_num != nil {
		*m.addthumb_num += i
	} else {
		m.addthumb_num = &i
	}
}

// AddedThumbNum returns the value that was added to the "thumb_num" field in this mutation.
func (m *TravelsMutation) AddedThumbNum() (r int, exists bool) {
	v := m.addthumb_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetThumbNum resets all changes to the "thumb_num" field.
func (m *TravelsMutation) ResetThumbNum() {
	m.thumb_num = nil
	m.addthumb_num = nil
}

// SetCollectNum sets the "collect_num" field.
func (m *TravelsMutation) SetCollectNum(i int) {
	m.collect_num = &i
	m.addcollect_num = nil
}

// CollectNum returns the value of the "collect_num" field in the mutation.
func (m *TravelsMutation) CollectNum() (r int, exists bool) {
	v := m.collect_num
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectNum returns the old "collect_num" field's value of the Travels entity.
// If the Travels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TravelsMutation) OldCollectNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectNum: %w", err)
	}
	return oldValue.CollectNum, nil
}

// AddCollectNum adds i to the "collect_num" field.
func (m *TravelsMutation) AddCollectNum(i int) {
	if m.addcollect_num != nil {
		*m.addcollect_num += i
	} else {
		m.addcollect_num = &i
	}
}

// AddedCollectNum returns the value that was added to the "collect_num" field in this mutation.
func (m *TravelsMutation) AddedCollectNum() (r int, exists bool) {
	v := m.addcollect_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectNum resets all changes to the "collect_num" field.
func (m *TravelsMutation) ResetCollectNum() {
	m.collect_num = nil
	m.addcollect_num = nil
}

// AddTravelExtendIDs adds the "travel_extends" edge to the TravelExtends entity by ids.
func (m *TravelsMutation) AddTravelExtendIDs(ids ...int) {
	if m.travel_extends == nil {
		m.travel_extends = make(map[int]struct{})
	}
	for i := range ids {
		m.travel_extends[ids[i]] = struct{}{}
	}
}

// ClearTravelExtends clears the "travel_extends" edge to the TravelExtends entity.
func (m *TravelsMutation) ClearTravelExtends() {
	m.clearedtravel_extends = true
}

// TravelExtendsCleared reports if the "travel_extends" edge to the TravelExtends entity was cleared.
func (m *TravelsMutation) TravelExtendsCleared() bool {
	return m.clearedtravel_extends
}

// RemoveTravelExtendIDs removes the "travel_extends" edge to the TravelExtends entity by IDs.
func (m *TravelsMutation) RemoveTravelExtendIDs(ids ...int) {
	if m.removedtravel_extends == nil {
		m.removedtravel_extends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.travel_extends, ids[i])
		m.removedtravel_extends[ids[i]] = struct{}{}
	}
}

// RemovedTravelExtends returns the removed IDs of the "travel_extends" edge to the TravelExtends entity.
func (m *TravelsMutation) RemovedTravelExtendsIDs() (ids []int) {
	for id := range m.removedtravel_extends {
		ids = append(ids, id)
	}
	return
}

// TravelExtendsIDs returns the "travel_extends" edge IDs in the mutation.
func (m *TravelsMutation) TravelExtendsIDs() (ids []int) {
	for id := range m.travel_extends {
		ids = append(ids, id)
	}
	return
}

// ResetTravelExtends resets all changes to the "travel_extends" edge.
func (m *TravelsMutation) ResetTravelExtends() {
	m.travel_extends = nil
	m.clearedtravel_extends = false
	m.removedtravel_extends = nil
}

// SetTravelAccountID sets the "travel_account" edge to the Account entity by id.
func (m *TravelsMutation) SetTravelAccountID(id int) {
	m.travel_account = &id
}

// ClearTravelAccount clears the "travel_account" edge to the Account entity.
func (m *TravelsMutation) ClearTravelAccount() {
	m.clearedtravel_account = true
	m.clearedFields[travels.FieldAccountID] = struct{}{}
}

// TravelAccountCleared reports if the "travel_account" edge to the Account entity was cleared.
func (m *TravelsMutation) TravelAccountCleared() bool {
	return m.AccountIDCleared() || m.clearedtravel_account
}

// TravelAccountID returns the "travel_account" edge ID in the mutation.
func (m *TravelsMutation) TravelAccountID() (id int, exists bool) {
	if m.travel_account != nil {
		return *m.travel_account, true
	}
	return
}

// TravelAccountIDs returns the "travel_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TravelAccountID instead. It exists only for internal usage by the builders.
func (m *TravelsMutation) TravelAccountIDs() (ids []int) {
	if id := m.travel_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTravelAccount resets all changes to the "travel_account" edge.
func (m *TravelsMutation) ResetTravelAccount() {
	m.travel_account = nil
	m.clearedtravel_account = false
}

// Where appends a list predicates to the TravelsMutation builder.
func (m *TravelsMutation) Where(ps ...predicate.Travels) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TravelsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TravelsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Travels, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TravelsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TravelsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Travels).
func (m *TravelsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TravelsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, travels.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, travels.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, travels.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, travels.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, travels.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, travels.FieldDeletedBy)
	}
	if m.title != nil {
		fields = append(fields, travels.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, travels.FieldDescription)
	}
	if m.video != nil {
		fields = append(fields, travels.FieldVideo)
	}
	if m.is_hidden != nil {
		fields = append(fields, travels.FieldIsHidden)
	}
	if m.travel_account != nil {
		fields = append(fields, travels.FieldAccountID)
	}
	if m.photos != nil {
		fields = append(fields, travels.FieldPhotos)
	}
	if m.browse_num != nil {
		fields = append(fields, travels.FieldBrowseNum)
	}
	if m.thumb_num != nil {
		fields = append(fields, travels.FieldThumbNum)
	}
	if m.collect_num != nil {
		fields = append(fields, travels.FieldCollectNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TravelsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case travels.FieldCreatedAt:
		return m.CreatedAt()
	case travels.FieldCreatedBy:
		return m.CreatedBy()
	case travels.FieldUpdatedAt:
		return m.UpdatedAt()
	case travels.FieldUpdatedBy:
		return m.UpdatedBy()
	case travels.FieldDeletedAt:
		return m.DeletedAt()
	case travels.FieldDeletedBy:
		return m.DeletedBy()
	case travels.FieldTitle:
		return m.Title()
	case travels.FieldDescription:
		return m.Description()
	case travels.FieldVideo:
		return m.Video()
	case travels.FieldIsHidden:
		return m.IsHidden()
	case travels.FieldAccountID:
		return m.AccountID()
	case travels.FieldPhotos:
		return m.Photos()
	case travels.FieldBrowseNum:
		return m.BrowseNum()
	case travels.FieldThumbNum:
		return m.ThumbNum()
	case travels.FieldCollectNum:
		return m.CollectNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TravelsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case travels.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case travels.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case travels.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case travels.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case travels.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case travels.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case travels.FieldTitle:
		return m.OldTitle(ctx)
	case travels.FieldDescription:
		return m.OldDescription(ctx)
	case travels.FieldVideo:
		return m.OldVideo(ctx)
	case travels.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case travels.FieldAccountID:
		return m.OldAccountID(ctx)
	case travels.FieldPhotos:
		return m.OldPhotos(ctx)
	case travels.FieldBrowseNum:
		return m.OldBrowseNum(ctx)
	case travels.FieldThumbNum:
		return m.OldThumbNum(ctx)
	case travels.FieldCollectNum:
		return m.OldCollectNum(ctx)
	}
	return nil, fmt.Errorf("unknown Travels field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case travels.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case travels.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case travels.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case travels.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case travels.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case travels.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case travels.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case travels.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case travels.FieldVideo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideo(v)
		return nil
	case travels.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case travels.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case travels.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	case travels.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseNum(v)
		return nil
	case travels.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbNum(v)
		return nil
	case travels.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travels field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TravelsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, travels.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, travels.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, travels.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, travels.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, travels.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, travels.FieldDeletedBy)
	}
	if m.addbrowse_num != nil {
		fields = append(fields, travels.FieldBrowseNum)
	}
	if m.addthumb_num != nil {
		fields = append(fields, travels.FieldThumbNum)
	}
	if m.addcollect_num != nil {
		fields = append(fields, travels.FieldCollectNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TravelsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case travels.FieldCreatedAt:
		return m.AddedCreatedAt()
	case travels.FieldCreatedBy:
		return m.AddedCreatedBy()
	case travels.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case travels.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case travels.FieldDeletedAt:
		return m.AddedDeletedAt()
	case travels.FieldDeletedBy:
		return m.AddedDeletedBy()
	case travels.FieldBrowseNum:
		return m.AddedBrowseNum()
	case travels.FieldThumbNum:
		return m.AddedThumbNum()
	case travels.FieldCollectNum:
		return m.AddedCollectNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TravelsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case travels.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case travels.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case travels.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case travels.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case travels.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case travels.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case travels.FieldBrowseNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseNum(v)
		return nil
	case travels.FieldThumbNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbNum(v)
		return nil
	case travels.FieldCollectNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectNum(v)
		return nil
	}
	return fmt.Errorf("unknown Travels numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TravelsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(travels.FieldAccountID) {
		fields = append(fields, travels.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TravelsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TravelsMutation) ClearField(name string) error {
	switch name {
	case travels.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown Travels nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TravelsMutation) ResetField(name string) error {
	switch name {
	case travels.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case travels.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case travels.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case travels.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case travels.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case travels.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case travels.FieldTitle:
		m.ResetTitle()
		return nil
	case travels.FieldDescription:
		m.ResetDescription()
		return nil
	case travels.FieldVideo:
		m.ResetVideo()
		return nil
	case travels.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case travels.FieldAccountID:
		m.ResetAccountID()
		return nil
	case travels.FieldPhotos:
		m.ResetPhotos()
		return nil
	case travels.FieldBrowseNum:
		m.ResetBrowseNum()
		return nil
	case travels.FieldThumbNum:
		m.ResetThumbNum()
		return nil
	case travels.FieldCollectNum:
		m.ResetCollectNum()
		return nil
	}
	return fmt.Errorf("unknown Travels field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TravelsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.travel_extends != nil {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	if m.travel_account != nil {
		edges = append(edges, travels.EdgeTravelAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TravelsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case travels.EdgeTravelExtends:
		ids := make([]ent.Value, 0, len(m.travel_extends))
		for id := range m.travel_extends {
			ids = append(ids, id)
		}
		return ids
	case travels.EdgeTravelAccount:
		if id := m.travel_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TravelsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtravel_extends != nil {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TravelsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case travels.EdgeTravelExtends:
		ids := make([]ent.Value, 0, len(m.removedtravel_extends))
		for id := range m.removedtravel_extends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TravelsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtravel_extends {
		edges = append(edges, travels.EdgeTravelExtends)
	}
	if m.clearedtravel_account {
		edges = append(edges, travels.EdgeTravelAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TravelsMutation) EdgeCleared(name string) bool {
	switch name {
	case travels.EdgeTravelExtends:
		return m.clearedtravel_extends
	case travels.EdgeTravelAccount:
		return m.clearedtravel_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TravelsMutation) ClearEdge(name string) error {
	switch name {
	case travels.EdgeTravelAccount:
		m.ClearTravelAccount()
		return nil
	}
	return fmt.Errorf("unknown Travels unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TravelsMutation) ResetEdge(name string) error {
	switch name {
	case travels.EdgeTravelExtends:
		m.ResetTravelExtends()
		return nil
	case travels.EdgeTravelAccount:
		m.ResetTravelAccount()
		return nil
	}
	return fmt.Errorf("unknown Travels edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *int64
	addcreated_at *int64
	created_by    *int64
	addcreated_by *int64
	updated_at    *int64
	addupdated_at *int64
	updated_by    *int64
	addupdated_by *int64
	deleted_at    *int64
	adddeleted_at *int64
	deleted_by    *int64
	adddeleted_by *int64
	name          *string
	avatar        *string
	email         *string
	professional  *string
	address       *string
	skills        *[]string
	appendskills  []string
	description   *string
	experience    *int
	addexperience *int
	project       *int
	addproject    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetProfessional sets the "professional" field.
func (m *UserMutation) SetProfessional(s string) {
	m.professional = &s
}

// Professional returns the value of the "professional" field in the mutation.
func (m *UserMutation) Professional() (r string, exists bool) {
	v := m.professional
	if v == nil {
		return
	}
	return *v, true
}

// OldProfessional returns the old "professional" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfessional(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfessional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfessional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfessional: %w", err)
	}
	return oldValue.Professional, nil
}

// ResetProfessional resets all changes to the "professional" field.
func (m *UserMutation) ResetProfessional() {
	m.professional = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetSkills sets the "skills" field.
func (m *UserMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
}

// SetExperience sets the "experience" field.
func (m *UserMutation) SetExperience(i int) {
	m.experience = &i
	m.addexperience = nil
}

// Experience returns the value of the "experience" field in the mutation.
func (m *UserMutation) Experience() (r int, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperience returns the old "experience" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExperience(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperience: %w", err)
	}
	return oldValue.Experience, nil
}

// AddExperience adds i to the "experience" field.
func (m *UserMutation) AddExperience(i int) {
	if m.addexperience != nil {
		*m.addexperience += i
	} else {
		m.addexperience = &i
	}
}

// AddedExperience returns the value that was added to the "experience" field in this mutation.
func (m *UserMutation) AddedExperience() (r int, exists bool) {
	v := m.addexperience
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperience resets all changes to the "experience" field.
func (m *UserMutation) ResetExperience() {
	m.experience = nil
	m.addexperience = nil
}

// SetProject sets the "project" field.
func (m *UserMutation) SetProject(i int) {
	m.project = &i
	m.addproject = nil
}

// Project returns the value of the "project" field in the mutation.
func (m *UserMutation) Project() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProject returns the old "project" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProject: %w", err)
	}
	return oldValue.Project, nil
}

// AddProject adds i to the "project" field.
func (m *UserMutation) AddProject(i int) {
	if m.addproject != nil {
		*m.addproject += i
	} else {
		m.addproject = &i
	}
}

// AddedProject returns the value that was added to the "project" field in this mutation.
func (m *UserMutation) AddedProject() (r int, exists bool) {
	v := m.addproject
	if v == nil {
		return
	}
	return *v, true
}

// ResetProject resets all changes to the "project" field.
func (m *UserMutation) ResetProject() {
	m.project = nil
	m.addproject = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.professional != nil {
		fields = append(fields, user.FieldProfessional)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.skills != nil {
		fields = append(fields, user.FieldSkills)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.experience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.project != nil {
		fields = append(fields, user.FieldProject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldName:
		return m.Name()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldEmail:
		return m.Email()
	case user.FieldProfessional:
		return m.Professional()
	case user.FieldAddress:
		return m.Address()
	case user.FieldSkills:
		return m.Skills()
	case user.FieldDescription:
		return m.Description()
	case user.FieldExperience:
		return m.Experience()
	case user.FieldProject:
		return m.Project()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldProfessional:
		return m.OldProfessional(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldSkills:
		return m.OldSkills(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldExperience:
		return m.OldExperience(ctx)
	case user.FieldProject:
		return m.OldProject(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldProfessional:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfessional(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperience(v)
		return nil
	case user.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProject(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.addexperience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.addproject != nil {
		fields = append(fields, user.FieldProject)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.AddedCreatedAt()
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	case user.FieldExperience:
		return m.AddedExperience()
	case user.FieldProject:
		return m.AddedProject()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperience(v)
		return nil
	case user.FieldProject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProject(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldProfessional:
		m.ResetProfessional()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldSkills:
		m.ResetSkills()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldExperience:
		m.ResetExperience()
		return nil
	case user.FieldProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserExperienceMutation represents an operation that mutates the UserExperience nodes in the graph.
type UserExperienceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	company          *string
	role             *string
	location         *string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	description      *string
	responsibilities *string
	achievements     *string
	skills           *[]string
	appendskills     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserExperience, error)
	predicates       []predicate.UserExperience
}

var _ ent.Mutation = (*UserExperienceMutation)(nil)

// userexperienceOption allows management of the mutation configuration using functional options.
type userexperienceOption func(*UserExperienceMutation)

// newUserExperienceMutation creates new mutation for the UserExperience entity.
func newUserExperienceMutation(c config, op Op, opts ...userexperienceOption) *UserExperienceMutation {
	m := &UserExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserExperienceID sets the ID field of the mutation.
func withUserExperienceID(id int) userexperienceOption {
	return func(m *UserExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserExperience
		)
		m.oldValue = func(ctx context.Context) (*UserExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserExperience sets the old UserExperience of the mutation.
func withUserExperience(node *UserExperience) userexperienceOption {
	return func(m *UserExperienceMutation) {
		m.oldValue = func(context.Context) (*UserExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserExperience entities.
func (m *UserExperienceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserExperienceMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserExperienceMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserExperienceMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserExperienceMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserExperienceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserExperienceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserExperienceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserExperienceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserExperienceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserExperienceMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserExperienceMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserExperienceMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserExperienceMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserExperienceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserExperienceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserExperienceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserExperienceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserExperienceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserExperienceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserExperienceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserExperienceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserExperienceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserExperienceMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserExperienceMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserExperienceMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserExperienceMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserExperienceMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *UserExperienceMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserExperienceMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserExperienceMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserExperienceMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserExperienceMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCompany sets the "company" field.
func (m *UserExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *UserExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetRole sets the "role" field.
func (m *UserExperienceMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserExperienceMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserExperienceMutation) ResetRole() {
	m.role = nil
}

// SetLocation sets the "location" field.
func (m *UserExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *UserExperienceMutation) ResetLocation() {
	m.location = nil
}

// SetStart sets the "start" field.
func (m *UserExperienceMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *UserExperienceMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *UserExperienceMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *UserExperienceMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *UserExperienceMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *UserExperienceMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *UserExperienceMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *UserExperienceMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *UserExperienceMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *UserExperienceMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetDescription sets the "description" field.
func (m *UserExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserExperienceMutation) ResetDescription() {
	m.description = nil
}

// SetResponsibilities sets the "responsibilities" field.
func (m *UserExperienceMutation) SetResponsibilities(s string) {
	m.responsibilities = &s
}

// Responsibilities returns the value of the "responsibilities" field in the mutation.
func (m *UserExperienceMutation) Responsibilities() (r string, exists bool) {
	v := m.responsibilities
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibilities returns the old "responsibilities" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldResponsibilities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibilities: %w", err)
	}
	return oldValue.Responsibilities, nil
}

// ResetResponsibilities resets all changes to the "responsibilities" field.
func (m *UserExperienceMutation) ResetResponsibilities() {
	m.responsibilities = nil
}

// SetAchievements sets the "achievements" field.
func (m *UserExperienceMutation) SetAchievements(s string) {
	m.achievements = &s
}

// Achievements returns the value of the "achievements" field in the mutation.
func (m *UserExperienceMutation) Achievements() (r string, exists bool) {
	v := m.achievements
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievements returns the old "achievements" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldAchievements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievements: %w", err)
	}
	return oldValue.Achievements, nil
}

// ResetAchievements resets all changes to the "achievements" field.
func (m *UserExperienceMutation) ResetAchievements() {
	m.achievements = nil
}

// SetSkills sets the "skills" field.
func (m *UserExperienceMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserExperienceMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UserExperience entity.
// If the UserExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserExperienceMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserExperienceMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserExperienceMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserExperienceMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// Where appends a list predicates to the UserExperienceMutation builder.
func (m *UserExperienceMutation) Where(ps ...predicate.UserExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserExperience).
func (m *UserExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserExperienceMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, userexperience.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userexperience.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userexperience.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userexperience.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userexperience.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userexperience.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, userexperience.FieldUserID)
	}
	if m.company != nil {
		fields = append(fields, userexperience.FieldCompany)
	}
	if m.role != nil {
		fields = append(fields, userexperience.FieldRole)
	}
	if m.location != nil {
		fields = append(fields, userexperience.FieldLocation)
	}
	if m.start != nil {
		fields = append(fields, userexperience.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, userexperience.FieldEnd)
	}
	if m.description != nil {
		fields = append(fields, userexperience.FieldDescription)
	}
	if m.responsibilities != nil {
		fields = append(fields, userexperience.FieldResponsibilities)
	}
	if m.achievements != nil {
		fields = append(fields, userexperience.FieldAchievements)
	}
	if m.skills != nil {
		fields = append(fields, userexperience.FieldSkills)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.CreatedAt()
	case userexperience.FieldCreatedBy:
		return m.CreatedBy()
	case userexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	case userexperience.FieldUpdatedBy:
		return m.UpdatedBy()
	case userexperience.FieldDeletedAt:
		return m.DeletedAt()
	case userexperience.FieldDeletedBy:
		return m.DeletedBy()
	case userexperience.FieldUserID:
		return m.UserID()
	case userexperience.FieldCompany:
		return m.Company()
	case userexperience.FieldRole:
		return m.Role()
	case userexperience.FieldLocation:
		return m.Location()
	case userexperience.FieldStart:
		return m.Start()
	case userexperience.FieldEnd:
		return m.End()
	case userexperience.FieldDescription:
		return m.Description()
	case userexperience.FieldResponsibilities:
		return m.Responsibilities()
	case userexperience.FieldAchievements:
		return m.Achievements()
	case userexperience.FieldSkills:
		return m.Skills()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userexperience.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userexperience.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userexperience.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userexperience.FieldUserID:
		return m.OldUserID(ctx)
	case userexperience.FieldCompany:
		return m.OldCompany(ctx)
	case userexperience.FieldRole:
		return m.OldRole(ctx)
	case userexperience.FieldLocation:
		return m.OldLocation(ctx)
	case userexperience.FieldStart:
		return m.OldStart(ctx)
	case userexperience.FieldEnd:
		return m.OldEnd(ctx)
	case userexperience.FieldDescription:
		return m.OldDescription(ctx)
	case userexperience.FieldResponsibilities:
		return m.OldResponsibilities(ctx)
	case userexperience.FieldAchievements:
		return m.OldAchievements(ctx)
	case userexperience.FieldSkills:
		return m.OldSkills(ctx)
	}
	return nil, fmt.Errorf("unknown UserExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case userexperience.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case userexperience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case userexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case userexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case userexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userexperience.FieldResponsibilities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibilities(v)
		return nil
	case userexperience.FieldAchievements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievements(v)
		return nil
	case userexperience.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	}
	return fmt.Errorf("unknown UserExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userexperience.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, userexperience.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userexperience.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userexperience.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userexperience.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userexperience.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, userexperience.FieldUserID)
	}
	if m.addstart != nil {
		fields = append(fields, userexperience.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, userexperience.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userexperience.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userexperience.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userexperience.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userexperience.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userexperience.FieldDeletedAt:
		return m.AddedDeletedAt()
	case userexperience.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userexperience.FieldUserID:
		return m.AddedUserID()
	case userexperience.FieldStart:
		return m.AddedStart()
	case userexperience.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userexperience.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userexperience.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userexperience.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userexperience.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userexperience.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case userexperience.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userexperience.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userexperience.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case userexperience.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown UserExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserExperienceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserExperienceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserExperienceMutation) ResetField(name string) error {
	switch name {
	case userexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userexperience.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userexperience.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userexperience.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userexperience.FieldUserID:
		m.ResetUserID()
		return nil
	case userexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case userexperience.FieldRole:
		m.ResetRole()
		return nil
	case userexperience.FieldLocation:
		m.ResetLocation()
		return nil
	case userexperience.FieldStart:
		m.ResetStart()
		return nil
	case userexperience.FieldEnd:
		m.ResetEnd()
		return nil
	case userexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case userexperience.FieldResponsibilities:
		m.ResetResponsibilities()
		return nil
	case userexperience.FieldAchievements:
		m.ResetAchievements()
		return nil
	case userexperience.FieldSkills:
		m.ResetSkills()
		return nil
	}
	return fmt.Errorf("unknown UserExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserExperienceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserExperienceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserExperienceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserExperienceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserExperience edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *int64
	addcreated_at    *int64
	created_by       *int64
	addcreated_by    *int64
	updated_at       *int64
	addupdated_at    *int64
	updated_by       *int64
	addupdated_by    *int64
	deleted_at       *int64
	adddeleted_at    *int64
	deleted_by       *int64
	adddeleted_by    *int64
	user_id          *int
	adduser_id       *int
	experience_id    *int
	addexperience_id *int
	title            *string
	description      *string
	skills           *[]string
	appendskills     []string
	start            *int64
	addstart         *int64
	end              *int64
	addend           *int64
	link             *string
	photos           *[]string
	appendphotos     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserProject, error)
	predicates       []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id int) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProject entities.
func (m *UserProjectMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserProjectMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserProjectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserProjectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserProjectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserProjectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserProjectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserProjectMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserProjectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserProjectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserProjectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserProjectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserProjectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserProjectMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserProjectMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserProjectMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserProjectMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserProjectMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserProjectMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserProjectMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserProjectMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserProjectMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserProjectMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserProjectMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetExperienceID sets the "experience_id" field.
func (m *UserProjectMutation) SetExperienceID(i int) {
	m.experience_id = &i
	m.addexperience_id = nil
}

// ExperienceID returns the value of the "experience_id" field in the mutation.
func (m *UserProjectMutation) ExperienceID() (r int, exists bool) {
	v := m.experience_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceID returns the old "experience_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldExperienceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceID: %w", err)
	}
	return oldValue.ExperienceID, nil
}

// AddExperienceID adds i to the "experience_id" field.
func (m *UserProjectMutation) AddExperienceID(i int) {
	if m.addexperience_id != nil {
		*m.addexperience_id += i
	} else {
		m.addexperience_id = &i
	}
}

// AddedExperienceID returns the value that was added to the "experience_id" field in this mutation.
func (m *UserProjectMutation) AddedExperienceID() (r int, exists bool) {
	v := m.addexperience_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperienceID resets all changes to the "experience_id" field.
func (m *UserProjectMutation) ResetExperienceID() {
	m.experience_id = nil
	m.addexperience_id = nil
}

// SetTitle sets the "title" field.
func (m *UserProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UserProjectMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *UserProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserProjectMutation) ResetDescription() {
	m.description = nil
}

// SetSkills sets the "skills" field.
func (m *UserProjectMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserProjectMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserProjectMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserProjectMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserProjectMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetStart sets the "start" field.
func (m *UserProjectMutation) SetStart(i int64) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *UserProjectMutation) Start() (r int64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *UserProjectMutation) AddStart(i int64) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *UserProjectMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *UserProjectMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *UserProjectMutation) SetEnd(i int64) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *UserProjectMutation) End() (r int64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *UserProjectMutation) AddEnd(i int64) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *UserProjectMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *UserProjectMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetLink sets the "link" field.
func (m *UserProjectMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *UserProjectMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *UserProjectMutation) ResetLink() {
	m.link = nil
}

// SetPhotos sets the "photos" field.
func (m *UserProjectMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *UserProjectMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *UserProjectMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *UserProjectMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *UserProjectMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userproject.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userproject.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userproject.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.experience_id != nil {
		fields = append(fields, userproject.FieldExperienceID)
	}
	if m.title != nil {
		fields = append(fields, userproject.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, userproject.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, userproject.FieldSkills)
	}
	if m.start != nil {
		fields = append(fields, userproject.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, userproject.FieldEnd)
	}
	if m.link != nil {
		fields = append(fields, userproject.FieldLink)
	}
	if m.photos != nil {
		fields = append(fields, userproject.FieldPhotos)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldCreatedBy:
		return m.CreatedBy()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case userproject.FieldUpdatedBy:
		return m.UpdatedBy()
	case userproject.FieldDeletedAt:
		return m.DeletedAt()
	case userproject.FieldDeletedBy:
		return m.DeletedBy()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldExperienceID:
		return m.ExperienceID()
	case userproject.FieldTitle:
		return m.Title()
	case userproject.FieldDescription:
		return m.Description()
	case userproject.FieldSkills:
		return m.Skills()
	case userproject.FieldStart:
		return m.Start()
	case userproject.FieldEnd:
		return m.End()
	case userproject.FieldLink:
		return m.Link()
	case userproject.FieldPhotos:
		return m.Photos()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userproject.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userproject.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldExperienceID:
		return m.OldExperienceID(ctx)
	case userproject.FieldTitle:
		return m.OldTitle(ctx)
	case userproject.FieldDescription:
		return m.OldDescription(ctx)
	case userproject.FieldSkills:
		return m.OldSkills(ctx)
	case userproject.FieldStart:
		return m.OldStart(ctx)
	case userproject.FieldEnd:
		return m.OldEnd(ctx)
	case userproject.FieldLink:
		return m.OldLink(ctx)
	case userproject.FieldPhotos:
		return m.OldPhotos(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceID(v)
		return nil
	case userproject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case userproject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userproject.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case userproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case userproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case userproject.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case userproject.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.addcreated_by != nil {
		fields = append(fields, userproject.FieldCreatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userproject.FieldUpdatedBy)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userproject.FieldDeletedBy)
	}
	if m.adduser_id != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.addexperience_id != nil {
		fields = append(fields, userproject.FieldExperienceID)
	}
	if m.addstart != nil {
		fields = append(fields, userproject.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, userproject.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userproject.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userproject.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userproject.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userproject.FieldDeletedAt:
		return m.AddedDeletedAt()
	case userproject.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userproject.FieldUserID:
		return m.AddedUserID()
	case userproject.FieldExperienceID:
		return m.AddedExperienceID()
	case userproject.FieldStart:
		return m.AddedStart()
	case userproject.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userproject.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userproject.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case userproject.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userproject.FieldExperienceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperienceID(v)
		return nil
	case userproject.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case userproject.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userproject.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userproject.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldExperienceID:
		m.ResetExperienceID()
		return nil
	case userproject.FieldTitle:
		m.ResetTitle()
		return nil
	case userproject.FieldDescription:
		m.ResetDescription()
		return nil
	case userproject.FieldSkills:
		m.ResetSkills()
		return nil
	case userproject.FieldStart:
		m.ResetStart()
		return nil
	case userproject.FieldEnd:
		m.ResetEnd()
		return nil
	case userproject.FieldLink:
		m.ResetLink()
		return nil
	case userproject.FieldPhotos:
		m.ResetPhotos()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserProject edge %s", name)
}
